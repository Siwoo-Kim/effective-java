
1. 프로그래밍은 문제 해결이다.
    :많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력을 '문제 해결 능력'이라 한다.

2. 문제 해결
    :문제 해결 능력은 추상적인 개념이기 때문에 단순 반복만으론 익힐 수 없다.
    :문제를 푸는 것이 아니라 '문제를 푸는 기술'을 연마해야 한다.

    @문제를 푸는 기술.
        :자신이 문제를 어떤 방식으로 해결하는지를 인식한다.
        :문제해결에서 자신이 약한 부분을 인지한다.

    문제 해결 과정.
        :문제를 해결하기 위해선 과정들을 세분화하라..
        1. 문제을 이해한다.
        2. 문제를 익숙한 용어로 재정의한다.
        3. 어떻게 풀지 계획을 세운다.
        4. 계획을 검증한다.
        3. 프로그램으로 구현한다.
        4. 어떻게 작동하는지 돌아보고, 개선 방법을 찾아본다.


        1. 문제를 읽고 이해하기.
            :문제 설명을 공격적("세심히") 읽으며 문제가 원하는 바를 완전히 이해하는 과정.
        2. 재정의와 추상화.
            :자신이 다루기 쉬운 개념을 이용해서, 문제를 자신의 언어로 풀어 쓴다.
            추상화란 복잡한 현실 세계의 개념들을 '현실의 본질'만 남겨두고 축약하여 다루기 쉽게 표현하는 과정이다.
        3. 계획 세우기.
            : 문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료구조를 선택.
        4. 계획 검증하기.
        5. 계획 수행하기.
        6. 회고하기.
            :문제를 풀 때마다 코드와 함께 자신의 경험을 기록으로 남겨라.

    문제 해결 전략.
        어려운 문제일수록 다양한 방법을 시도해 답안을 찾아야 한다.
        아래에서는 사용할 수 있는 가장 일반적 전략을 소개한다.

        1. 직관과 체계적인 접근.
            :직관은 해당 문제를 해결하는 알고리즘이 어떤 형태를 가질지를 '짐작'할 수 있게 해준다.
            :직관은 막막한 문제들을 해결하며 경험을 통해 쌓여간다.
            :직관이 부족하다면 백지에서 시작해 문제를 해결하기 위한 기반을 차근차근 쌓아올리는 점진적 전진 방식을 '체계적인 방법'이라 한다.

        2.체계적인 접근을 위한 질문들.
            1. 비슷한 문제를 풀어본 적이 있던가?
                :완전히 같은 문제를 다시 만나기란 희박하지만, 기본에 해결했던 문제의 원리를 이용해 변형해서 사용한다.
            2. 단순한 방법에서 시작해볼까?
            3. 문제를 푸는 과정을 수식화할 수 없을까?
            4. 문제를 단순화할 수 없을까?
                :문제를 좀더 쉬운 변형판을 먼저 풀어본다.

알고리즘 분석.
    :알고리즘을 평가하는 두 가지의 큰 기준은 시간과 공간이다.

    1. 시간 복잡도
        :알고리즘이 적은 시간을 사용하다는 것은 빠르게 동작하단 말이다.
    2. 공간 복잡도
        :알고리즘이 적은 공간을 사용한다는 것은 더 적은 용량의 메모리를 사용한다는 것이다.

    알고리즘의 시간 복잡도 분석.
        :프로그램의 실행 시간은 하드웨어 요소에 의해 바뀔 수 있기 때문에 알고리즘의 속도을 적용하기엔 부적합하다.

        시간 복잡도는 반복문이 지배한다.
            :대부분은 입력의 크기에 따라 반복문의 수행 횟수가 정해진다.
            :반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현한다.

        ex) 수행 시간은 배열의 크기 N에 따라 변한다. N 번이 두 개 겹쳐있으므로 시간 복잡도는 N^2.
        static int majority(int[] array) {
            int m = -1, count = 0;
            for (int i=0, n=array.length; i<n; i++) {
                int c = 0, v= array[i];
                for (int j=0; j<n; j++) {
                    if (v == array[j])
                        c++;
                }
                if (c > count) {
                    m = v;
                    count = c;
                }
            }
            return m;
        }

        ex)  N+101 이지만 N 의 갯수가 커져도 101은 그대로이므로 수행 시간은 N 이다.
        static int majority(int[] array) {
            final int max = 101, min = 0;
            int[] c = new int[max];
            for (int i=0,n=array.length; i<n; i++)
                c[array[i]]++;
            int r = 0;
            for (int i=min; i<max; i++)
                if (c[r]<c[i])
                    r=i;
            return r;
        }

    선형 시간 알고리즘.

