생성자 대신 정적 팩토리 메서드를 고려하라.
    static factory method.
        1. 이름을 가질 수 있다.
        2. 불변 클래스 혹은 인스턴스를 미리 만들어 캐시하여 사용할 수 있다.
        Flyweight pattern.
            lyweight pattern is one of the structural design patterns as this pattern provides ways to decrease object count thus improving application required objects structure.
            Flyweight pattern is used when we need to create a large number of similar objects (say 105).
            One important feature of flyweight objects is that they are immutable. This means that they cannot be modified once they have been constructed.

            Why do we care for number of objects in our program?
            Less number of objects reduces the memory usage, and it manages to keep us away from errors related to memory like java.lang.OutOfMemoryError.
            Although creating an object in Java is really fast, we can still reduce the execution time of our program by sharing objects.

            In Flyweight pattern we use a HashMap that stores reference to the object which have already been created, every object is associated with a key.
            Now when a client wants to create an object, he simply has to pass a key associated with it and if the object has already been created we simply get the reference to that object else it creates a new object and then returns it reference to the client.

            class PlayerFactory {
                /* HashMap stores the reference to the object
                   of Terrorist(TS) or CounterTerrorist(CT).  */
                private static HashMap <String, Player> hm = new HashMap<String, Player>();

                // Method to get a player
                public static Player getPlayer(String type) {
                    Player p = null;
                    /* If an object for TS or CT has already been
                       created simply return its reference */
                    if (hm.containsKey(type))
                            p = hm.get(type);
                    else {
                        /* create an object of TS/CT  */
                        switch(type)
                        {
                        case "Terrorist":
                            System.out.println("Terrorist Created");
                            p = new Terrorist();
                            break;
                        case "CounterTerrorist":
                            System.out.println("Counter Terrorist Created");
                            p = new CounterTerrorist();
                            break;
                        default :
                            System.out.println("Unreachable code!");
                        }

                        // Once created insert it into the HashMap
                        hm.put(type, p);
                    }
                    return p;
                }

            객체의 내부에서 참조하는 객체가 없다면 만들고, 만들어져 있다면 객체를 공유하는 식으로
            구성. 객체의 할당에 사용되는 메모리를 줄이며 객체 생성하는 시간도 들지 않게 한다.
            ex) 자바의 String pool, Boolean.valueOf

        3. 반복되는 요청에 같은 객체를 반환하는 식으로 인스턴스 통제(instance-controlled) 클래스를
        생성할 수 있다.

        4. Return 시 Subclass 객체를 반환할 수 있다. (팩토리 패턴 -> 팩토리 패턴은 공통의 코드는 부모 클래스에 두고 달라지는 부분을 담당하는 객체의 생성은 자식 클래스에 위임한다.)
            반환할 클래스를 자유롭게 선택할 수 있는 "유연성"을 제공한다.
            서브 클래스는 Inner 클래스로 만들어 정의하는 것이 관례이다.
            클라이언트는 해당 클래스(API) 를 사용하기 위해 익혀야 하는 개념적인 무게를 낮춘다.
            ex) Collections

        5. static factory method 의 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
            ex) EnumSet. (원소가 64개 이하면 RegularEnumSet, 65개 이상이면 JumboEnumSet 인스턴스를 반환.)
            클라이언트는 이 두 클래스의 존재를 모른채 사용할 수 있다.
        6. 정적 팩터리 메서드를 작성하는 시점에는 반화할 객체의 클래스가 존재하지 않아도 된다.
            서비스 제공자 프레임워크(Service provider framework)
                서비스 제공자 프레임워크는 다양한 서비스 제공자들이 하나의 서비스를 구성하는 시스템으로, 클라이언트가
                실제 구현 내용을 몰라도 서비스를 이용할 수 있다.
                ex) JDBC 는 MySQL, Oracle, Postgresql 등 다양한 서비스 제공자들이 JDBC 라는 클라이언트가 하나의 서비스를 이용할 수 있게 한다.

                서비스 제공자 프레임워크의 핵심 컴포넌트.
                    1. 서비스 제공자가 구현하는 서비스 인터페이스
                        ex) JDBC Connection
                    2. 구현체를 시스템에 등록하여 클라이언트가 쓸 수 있도록 하는 서비스 등록 API.
                        ex) Class.forName -> DriverManager.registerDriver
                    3. 클라이언트에게 실제 서비스 구현체를 제공하는 서비스 접근 API.
                        ex) DriverManager.getConnection()
                브릿지 패턴 Bridge Pattern
                    브릿지 패턴은 구현 클래스 계층과 추상 클래스 계층을 분리.
        7. 상속을 하려면 public 이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.
        Collections 의 immutable, sync 컬렉션들은 상속될 수 없다.

        정적 팩토리 메서에 흔히 사용하는 명명 방식.
            from - 매개변수를 하나 받아 해당 타입의 인스턴스를 반환하는 형변환 메서드. 1 - 1
            of - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드. 1.. - 1..
            getInstance - 인스턴스를 반환하지만 같은 인스터임을 보장하지 않는다.
            newInstance - 매번 새로운 인스턴스를 반환.
            get[TYPE] - 인스턴스를 반환하나 다른 클래스의 팩토리 메서드를 정의할 때.
            new[TYPE] - 인스턴스를 생성하나 다른 클래스의 팩토리 메서드를 정의할 때.

        핵심 정리.
            정적 팩토리 메서드를 사용하는 게 생성자를 사용하는 것보다 더 많으므로 public 생성자를 제공하던 습관이 있다몬 고치자.

생성자에 매개변수가 많다면 빌더를 고려하라.
    생성자는 선택적 매개변수가 많을 때 적절히 대응하기 어렵다.
    점층적 생성자 패턴은, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.

    public class NutritionFacts {

        private final int servingSize;
        private final int servings;
        private final int calories;
        private final int fat;
        private final int sodium;
        private final int carbohydrate;

        public NutritionFacts(int servingSize, int servings) {
            this(servingSize, servings, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories) {
            this(servingSize, servings, calories, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat) {
            this(servingSize, servings, calories, fat, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
            this(servingSize, servings, calories, fat, sodium, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
            this.servingSize = servingSize;
            this.servings = servings;
            this.calories = calories;
            this.fat = fat;
            this.sodium = sodium;
            this.carbohydrate = carbohydrate;
        }

        public static void main(String[] args) {
            //순서에 따른 프러퍼티를 설정하므로 가독성이 떨어진다.
            NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);

        두번째 대안인 자바빈즈 패턴의 setter 메서드를 호출을 사용하여 더 읽기 쉬운 코드를 만들 수 있찌만 객체 하나를 만들려면
        메서드를 여러 개 호출해야 하고, 객체가 생성되기 전까지 일관성 (consistency) 가 무너지며, 불변 클래스를 만들 수 없게 한다.


    public class NutritionFacts {
        //setter 로 프러퍼티를 설정하므로 불변 클래스를 생성할 수 없게 한다.
        private int servingSize = -1;
        private int servings = -1;
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public void setServingSize(int servingSize) {
            this.servingSize = servingSize;
        }

        public void setServings(int servings) {
            this.servings = servings;
        }

        public void setCalories(int calories) {
            this.calories = calories;
        }

        public void setFat(int fat) {
            this.fat = fat;
        }

        public void setSodium(int sodium) {
            this.sodium = sodium;
        }

        public void setCarbohydrate(int carbohydrate) {
            this.carbohydrate = carbohydrate;
        }

        public static void main(String[] args) {
            NutritionFacts cocaCola = new NutritionFacts();
            cocaCola.setServingSize(240);
            cocaCola.setServings(8);
            cocaCola.setCalories(100);
            cocaCola.setSodium(35);
            cocaCola.setCarbohydrate(27);
            //이 시점 이전까지는 객체의 일관성을 지킬 수 없다.

    빌더 패턴은 점층적 생성자 패턴의 안전성과 자바빈드 패턴의 가독성을 겸비하며 불변 클래스를 생성할 수 있다.
    빌더 패턴을 생성할 때, "필수 매개변수"을 전달하여 빌더 객체를 얻은 이후 세터 메서드로 원하는 선택 매개변수를 설정한다.
    마지막으로 매개변수가 없는 build 메서드를 호출해 필요한 객체를 얻는다. "빌더" 는 생성한 클래스 안에 정적 멤버 클래스로 만드는 것이 관례이다.
    빌더의 생성자와 메서드에 입력 매개변수를 검사하고 어떤 매개변수가 잘못되었는지를 자세히 알려주는 메세지를 담아 IllegalArgumentException 던져라.

        public class NutritionFacts {

            private final int servingSize;
            private final int servings;
            private final int calories;
            private final int fat;
            private final int sodium;
            private final int carbohydrate;

            private NutritionFacts(Builder builder) {
                this.servingSize = builder.servingSize;
                this.servings = builder.servings;
                this.calories = builder.calories;
                this.fat = builder.fat;
                this.sodium = builder.sodium;
                this.carbohydrate = builder.carbohydrate;
            }

            static final class Builder {
                //필수 매개변수
                private final int servingSize;
                private final int servings;
                //선택 매개변수 - 기본값으로 초기화
                private int calories = 0;
                private int fat = 0;
                private int sodium = 0;
                private int carbohydrate = 0;

                public Builder(int servingSize, int servings) {
                    this.servingSize = servingSize;
                    this.servings = servings;
                }

                public Builder calories(int calories) {
                    this.calories = calories;
                    return this;
                }

                public Builder fat(int fat) {
                    this.fat = fat;
                    return this;
                }

                public Builder sodium(int sodium) {
                    this.sodium = sodium;
                    return this;
                }
                public Builder carbohydrate(int carbohydrate) {
                    this.carbohydrate = carbohydrate;
                    return this;
                }
                public NutritionFacts build() {
                    return new NutritionFacts(this);
                }

            }

            @Override
            public String toString() {
                return "NutritionFacts{" +
                        "servingSize=" + servingSize +
                        ", servings=" + servings +
                        ", calories=" + calories +
                        ", fat=" + fat +
                        ", sodium=" + sodium +
                        ", carbohydrate=" + carbohydrate +
                        '}';
            }

            public static void main(String[] args) {
                NutritionFacts cocaCola = new Builder(240, 8)
                        .calories(100).sodium(35).carbohydrate(27)
                        .build();

    불변(Immutable) 은 어떠한 변경도 허용하지 않는다는 뜻으로, 주로 변경을 허용하는 가변(mutable) 객체와 구분하는 용도로 쓰인다.
    ex) String 객체는 한번 만들어지면 절대 값을 바꿀 수 없는 불변 객체다.
    불변식(invariant) 은 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야 하는 조건을 말한다.
    다시 말해 변경을 허용할 수 있으나, 주어진 조건 내에서는 변경을 허용하지 않는다.
    ex) 리스트의 크기는 반드시 0 이상이어야 하니, 한순간이라도 음수 값이 된다면 불변식이 깨진다.
    Period 클래스에 start 필드의 값은 반드시 end 필드의 값보다 앞서야 한다.

    빌더 패턴은 계층적으로 설계된 클래스 (추상화된 클래스) 와 함께 쓰기에 좋다.
    제네릭 추상 클래스를 상속한 클래스에서 추상 메서드 self 을 정의한다면 하위 클래스에서는 형변환하지 않고 서브 클래스 타입을 지원할 수 있다.
    공변 반환 타이핑(covariant return typing)
        하위 클래스의 메서드가 오브라이드 되어 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(covariant return typing) 이라 한다.

        public abstract class Pizza {
            public enum TOPPING { HAM, MUSHROOM, ONION, PEPEER, SAUSAGE }
            private final Set<TOPPING> toppings;

            public Pizza(Builder builder) {
                this.toppings = builder.toppings.clone();
            }

            abstract static class Builder<T extends Builder<T>> {
                private EnumSet<TOPPING> toppings = EnumSet.noneOf(TOPPING.class);

                public T addTopping(TOPPING topping) {
                    toppings.add(Objects.requireNonNull(topping));
                    return self();
                }

                public abstract Pizza build();
                //하위 클래스는 이 메서드를 재정의(Overriding) 하여 "this"  를 반환해야 한다.
                //T 은 하위 클래스를 가리킨다.
                protected abstract T self();
            }

            public static void main(String[] args) {
                NyPizza pizza = new NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION)
                        .build();
                Calzone calzone = new Calzone.Builder().sauceInside().addTopping(HAM)
                        .build();
            }
        }

        class NyPizza extends Pizza {
            public enum SIZE { SMALL, MEDIUM, LARGE }
            private final SIZE size;

            public NyPizza(Builder builder) {
                super(builder);
                this.size = builder.size;
            }

            public static class Builder extends Pizza.Builder<Builder> {
                private final SIZE size;

                public Builder(SIZE size) {
                    this.size = Objects.requireNonNull(size);
                }

                @Override
                //covariant return typing
                public NyPizza build() {
                    return new NyPizza(this);
                }

                @Override
                protected Builder self() {
                    return this;
                }
            }
        }

        class Calzone extends Pizza {
            private final boolean sauceInside;

            public Calzone(Builder builder) {
                super(builder);
                this.sauceInside = builder.sauceInside;
            }

            public static class Builder extends Pizza.Builder<Builder> {
                //선택적 매개변수 - 기본값
                private boolean sauceInside = false;

                public Builder sauceInside() {
                    this.sauceInside = true;
                    return this;
                }

                @Override
                public Calzone build() {
                    return new Calzone(this);
                }

                @Override
                protected Builder self() {
                    return this;
                }
            }
        }

    빌더 패턴은 성능에 민간한 상황에서는 문제가 될 수 있으니, 매개 변수가 4개 이상일때만 사용하자.

    핵심 정리
        생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다. 매개변수 중 다수가 필수가 아닌 경우에도 빌더 패턴이 낫다.
        빌더는 점층적 생성자보다 가독성이 좋고 쓰기 간편하며, 자바빈즈보다 훨씬 안전하다 (검증, 객체 일관성, 불변 클래스).

private 생성자나 열거 타입으로 싱글턴임을 보증하라.
    싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.
    싱글턴의 전형적인 예로는 함수와 같은 무상태(stateless) 객체나 설계장 유일해야 하는 시스템 컴포넌트(Configuration Registry) 를 들 수 있다.
    하지만 클래스를 싱글턴으로 만들면 이를 사용하는 클라리언트를 "테스트" 하기가 어려워질 수 있다. (싱글턴 인스턴스를 mock 으로 대체할 수 없다).
        * 인터페이스를 구현해서 만든 싱글턴은 싱글턴 인스턴스를 mock 으로 대체할 수 있다.

     싱글턴 생모두 생성자는 private 으로, 유일한 인스턴스에 접근하는 수단으로 public static 멤버 혹은 정적 팩토리 메서드를 둔다.
        * 싱글턴은 클라이언트의 리플렉션 API 의 AccessibleObject.setAccessible 을 사용해 private 생성자를 호출할 수 있다.

        public class Elvis {
            private static final Elvis INSTANCE = new Elvis();
            private Elvis() { }
            private static final Elvis getInstance() { return INSTANCE; }

            public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException {
                Elvis elvis = null;
                for (Constructor constructor: Elvis.class.getDeclaredConstructors()) {
                    if (constructor.getParameterCount() == 0) {
                        constructor.setAccessible(true);
                        elvis = (Elvis) constructor.newInstance(null);
                    }
                };
                System.out.println(elvis == Elvis.getInstance());
            }
        }

    싱글턴을 만드는 마지막 방법은 "원소가 하나인" 열거 타입을 선거하라.
    더 간결하고, 추가 노력 없이 직렬화할 수 있으며, 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아준다.
    대부분 상황에서는 "원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다."
        enum Elvis {
            INSTANCE;

            public void leaveTheBuilding() { }
        }

자원(의존 객체)를 직접 명시하지 말고 의존 객체 주입을 사용하라.
    많은 클래스가 하나 이상의 자원에 의존한다.
    ex) 맞춤법 검사기는 사전(dictionary) 에 의존하는데, 이런 클래스를 정적 유틸리티 클래스로 구현한다.

    //정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.
    public class SpellChecker {
        //자원 구현 클래스가 직접 명시되므로 컴파일시 자원이 고정된다.
        private static final Lexion dictionary = new Lexion();

        private SpellChecker() { }

        public static boolean isValid(String word) {
            return dictionary.contains(word);
        }
        public static List<String> suggestions(String typo) {
            return dictionary.getSynomouys(typo);
        }
    }

    모두 사전을 단 하나만 사용한다고 가정한다는 점에서 문제점이 있다. 사전은 언어별로 따로 있고, 테스트용 사전도 필요할 수 있다.
    "사용하는 자원에 따라 동작이 달라지는 클래스"에는 정적 유틸리티 클래스나 싱글턴 방식은 적합하지 않다.

    public class SpellChecker {
        private final Lexion dictionary;

        //의존 주입.
        private SpellChecker(Lexion dictionary) {
            this.dictionary = Objects.requireNonNull(dictionary);
        }

        public boolean isValid(String word) {
            return dictionary.contains(word);
        }
        public List<String> suggestions(String typo) {
            return dictionary.getSynomouys(typo);
        }
    }

    의존 주입과 팩토리 메서드 패턴을 조합하면 코드의 좀 더 유연성을 추가할 수 있다.
    팩토리?
        팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체.
    java.util.Supplier 인터페이스.
        팩토리를 대체할 수 있는 함수형 인터페이스.

    public class SpellChecker {
        private final Lexion dictionary;

        //의존 주입.
        private SpellChecker(Supplier<? extends Lexion> dictionaryFactory) {
            //의존 객체의 생성을 dictionaryFactory 에게 위임한다.
            this.dictionary = Objects.requireNonNull(dictionaryFactory.get());
        }

        public boolean isValid(String word) {
            return dictionary.contains(word);
        }
        public List<String> suggestions(String typo) {
            return dictionary.getSynomouys(typo);
        }
    }

    클래스가 내부적으로 하나 이상의 자원(의존 객체)에 의존하고, 그 자원이 클래스 동작에 영향(의존성, 결합도)을 준다면 해당 클래스를 싱글턴과
    정적 유틸리티 클래스로 정의하지 마라. 이 자원들을 클래스가 직접 만들게 (의존성에 대해 최소한의 정보만 노출하라) 하지 마라.
    대신 필요한 자원 (혹은 그 자원을 만들어주는 팩토리) 를 생성자에 넘겨주라. 의존 객체 주입이라는 기법은 클라이언트의 유연성, 재사용성, 테스트 용이성을 기막히개 개선해준다.

불필요한 객체 생성을 피하라.
    똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하라 (더 빠르고 세련되다).
    불볍 객체는 언제든 재사용할 수 있다.
    ex) String s = new String("bikini"); //따라 하지 말 것!
            반복문에서 쓸데없는 인스턴스가 수백만 개 만들어질 수 있다.
        String s = "bikini";
            새로운 인스턴스 대신 하나의 String 인스턴스를 재사용한다.

    객체를 재사용하려면 생성자 대신 정적 팩토리 메서드를 정의해야 한다.
    ex) Boolean(String) 생성자 대신 Boolean.valueOf(String) 을 사용하면 객체를 재사용한다.

        String str1 = new String("bikini");
        String str2 = new String("bikini");
        String str3 = "bikini";
        String str4 = "bikini";
        System.out.println(str1 == str2); // false
        System.out.println(str3 == str4); // true (재사용)

        Boolean b1 = new Boolean(true);
        Boolean b2 = new Boolean(true);
        Boolean b3 = Boolean.valueOf("TRUE");
        Boolean b4 = Boolean.valueOf("true");
        System.out.println(b1 == b2); // false
        System.out.println(b3 == b4); // true (재사용)

    비싼 객체가 반복해서 필요하다면 캐싱하여 재사용하라.
        Number.instance .isRomanNumeral("XI"));

        enum Number {
            instance;

            //String.matches 은 내부적으로 Pattern.matches 을 사용한다.
            //아래 코드는 비싸게 생성한 Pattern 인스턴스를, 한번 생성하고 버려진다.
            public boolean isRomanNumeral(String s) {
                return s.matches("^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
            }
        }


        Number.ROMAN.isRomanNumeral("XI");

        enum Number {
            ROMAN("^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
            final Pattern pattern; //값 비싼 Pattern 객체를 재사용해 성능을 개선하라.

            Number(String s) {
                pattern = Pattern.compile(s);
            }

            //성능이 6.5배 개선된다.
            public boolean isRomanNumeral(String s) {
                return pattern.matcher(s).matches();
            }
        }

    지연 초기화.
        메서드를 처음 호출될 때까지 필드를 초기화를 미루는 기법을 지연 초기화라고 한다.
        지연 초기화는 코드를 복잡하게 만드는 데 비해, 성능은 크게 개선되지 않을때가 많으니 비싼 객체를 생성할때만 적용하라.

    어뎁터 패턴.(Adapter)
        한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.
        어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

        //다른 인터페이스를 사용하는 클라이언트를 위해 Turkey 을 사용할 수 있게 어뎁터 인터페이스를 통해 Turkey 인터페이스와 클라이언트를 연결.
        //Duck 인터페이스를 구현한다.
        public class TurkeyAdapter implements Duck {
            //실제 업무는 Turkey 가 담당한다.
            Turkey turkey;
            public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; }

            @Override
            public void quack() { turkey.gobble(); }

            @Override
            public void fly() { turkey.fly(); }
         }

    Map 인터페이스의 keySet 메서드는 Map 객체 안의 키 전부를 담은 Set 뷰를 반환한다.
    이 뷰는 실제 Map 내부의 키를 저장한 Set 이므로 해당 Set 을 변경하면 Map 의 자료구조 또한 변경된다.
     Map<String, Integer> maps = new HashMap<>();
     maps.put("1", 1);
     maps.put("2", 2);
     maps.put("3", 3);
     maps.keySet().removeIf(key -> key.equals("1"));
     System.out.println(maps.keySet()); [2, 3]

다 쓴 객체 참조를 해제하라.
    자바는 가비지 컬렉터가 메모리를 대신 관리해준다 (다 쓴 객체를 가비지 컬렉터가 회수).

    public class Stack {
        private Object[] elements;
        private int size = 0;
        public static final int DEFAULT_INITIAL_CAPACITY = 16;

        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            // 아직 elements 은 다 쓴 참조(obsolete reference) 를 알고 있으므로 가비지 컬렉터에 회수되지 않는다.
            return elements[--size];
        }

        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }

    가비지 컬렉션 언어에서는 메모리 누스를 찾기가 아주 까다로우며, 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 참조하는 모든 객체를 회수하지 못한다.
    그래서 단 몇 개의 객체가 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.

    해당 참조를 다 썼을 대 null 처리(참조 해제)를 해야 한다.

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // 다 쓴 참조 해제
        return result;
    }

    다 쓴 참조에 null 처리를 하면 따라오는 이점은 아래와 같다.
        1. 가비지 컬렉터에게 명시적으로 메모리를 회수하라 예약한다.
        2. 다 쓴 참조를 실수로 사용하려 하면 NullPointerException 이 던져진다.

    null 처리를 해야하는 경우
        객체 참조를 null 처리하는 일은 코드를 지저분하게 만든다.
        변수의 범위를 최소가 되게 정의했다면 null 처리가 필요없다.
        자기 메모리를 직접 관리하는 클래스(Stack)라면 프로그래머는 항시 메모리 누수에 주의해야 한다.

    캐시 역시 메모리 누수를 일으키는 주법이다.
        캐시 사용시 WeakHashMap 을 사용해 캐시를 만들면 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아있는다.
        캐시 엔트리를 청소해주기 위해 ScheduledThreadPollExecutor (백그라운드 쓰레드)를 활용한다.
        LinkedHashMap 의 removeEldestEntry 메서드를 사용한다.

    핵심 정리.
        메모리 누수를 해방하는 예방법 중 하나는 obsolete reference 을 null 처리하는 것이다.

try-finally 보다는 try-with-resources 를 사용하라.
    자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다.
    ex) InputStream, OutputStream, java.sql.Connection
    자원 닫기는 놓치기 쉬워 성능 문제로 이어진다.

    // try-finally 은 장황하고 자원이 둘 이상이면 더 지저분하며 예외 발생시 스택 추적이 어렵다.
    public enum Source {
        instance;
        private static final int DEFAULT_BUFFER = 8192;

        public String firstOfLine(String path) throws IOException {
            BufferedReader reader = new BufferedReader(new FileReader(path));
            try {
                return reader.readLine();
            } finally {
                reader.close();
            }
        }

        public void copy(String src, String des) throws IOException {
            InputStream in = new FileInputStream(src);
            try {
                OutputStream out = new FileOutputStream(des);
                try {
                    byte[] buf = new byte[DEFAULT_BUFFER];
                    int n;
                    while ((n = in.read(buf)) != -1)
                        out.write(buf, 0, n);
                } finally {
                    out.close();
                }
            } finally {
                in.close();
            }
        }
    }

    예외는 try 블럭과 finally 블록 모두에서 발생되지만 마지막 예외가 이전 예외를 완전히 덮어쓰므로 디버깅을 어렵게 한다.

    try-with-resources 을 사용하려는 자원은 AutoCloseable 인터페이스를 구현해야 한다.
    try-with-resources 은 close 블럭이 사라지므로 실행 블럭에서의 예외가 기록된다. 또한 숨겨진 예외들도 스택 추적 내역에 기록되므로
    Throwable.getSuppressed 메서드를 이용해 확인할 수 있다.

    //try-finally 보다 try-with-resource 가 간결하며 디버깅이 용이하다.
    public enum Source {
        instance;

        public String firstLineOfFile(String path) throws IOException {
            try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
                return reader.readLine();
            }
        }

        public void copy(String src, String dst) throws IOException {
            try (InputStream in = new FileInputStream(src);
                 OutputStream out = new FileOutputStream(dst)) {
                byte[] buf = new byte[8192];
                int n;
                while ((n = in.read(buf)) != -1)
                    out.write(buf, 0, n);
            }
        }

    핵심 정리
        try-finally 말고 tray-with-resources 를 사용하자.
        코드는 더 짧고 분명해지며, 만들어지는 예외 정보도 훨씬 유용하며 정확하고 쉽게 자원을 회수할 수 있다.

모든 객체의 공통 메서드.
    Object 은 객체를 만들 수 있는 구체 클래스지만 기본적으로 상속해서 사용하도록 설계되었다.
    Object 에는 equals, hashCode, toString, clone 이 정의되 있으며, 모두 재정의(overriding) 을 염두에 두고 설계된 것이다.
    위의 equals, hashCode, toString, clone 메서드 재정의시 지켜야 하는 규약등이 명확히 정의되어 있다.

equals 은 규약을 지켜 정의하라.
    equals 을 규약에 지켜 재정의하지 않으면 문제가 발생한다.
    아래에 상황 중 하나라도 해당하다면, 재정의하지 않는 것이 최선이다.
    1. 각 인스턴스가 본질적으로 고유.
    ex) Thread
    2. 인스턴스의 논리적 동치성(logical equality) 을 검사할 일이 없다.
    ex) Pattern (설계자는 Pattern 의 equals 은 필요하지 않다고 판단)
    3. 상위 클래스에서 재정의한 equals 가 하위 클래스에도 딱 들어맞는다.
    ex) Set의 구현체들은 AbstractSet 의 equals 을 상속받아 쓴다.
    4. 값 클래스이지만, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스(static factory method를 통해 생성된 클래스).
        ex) Enum

    equals 을 정의해야할 때.
    객체 식별성(object identity) 가 아니라 논리적 동치성을 확인해야할 때.
    주로 값 클래스. ex) Integer, String.

    equals 을 활용도
        equals 가 논리적 동치성을 확인하도록 정의해두면 Map 의 키와 Set 의 원소로 사용할 수 있다.

    equals 의 규약.
        1. 반사성(reflexivity). 참조값 x에 대해 x.equals(x) 는 true.
        2. 대칭성(symmetry). 참조값 x,y에 대해, x.equals(y) 라면 y.equals(x) 도 true.
        3. 추이성(transitivity). 참조값 x,y,z 에 대해, x.equals(y) 이고, y.equals(z) 라면 x.equals(z) 은 true.
        4. 일관성(consistency), 참조값 x,y 에대해, x.equals(y) 를 반복해서 호출해도 항상 같은 값을 반환.
        5. null-아님. null 이 아닌 x에 대해, x.equals(null) 은 항상 false.

    1. 반사성. 객체는 자기 자신과 같아야 한다.
        x.equals(x) 가 false 라면 인스턴스를 컬렉션에 넣은 다음 contains 메서드를 호출하면 방금 넣은 인스턴스가 없다고 말한다.
        (사실 아님, contains 은 내부적으로 hash code 를 사용).
    2. 대칭성. 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.

    public class CaseInsensitiveString {
        private String s;

        public CaseInsensitiveString(String s) {
            this.s = s;
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof CaseInsensitiveString)
                return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
            if (o instanceof String) // 한 반향으로만 동작.
                return s.equalsIgnoreCase((String) o);
            return false;
        }

        public static void main(String[] args) {
            CaseInsensitiveString x = new CaseInsensitiveString("Polish");
            String y = "polish";
            System.out.println(x.equals(y)); //true
            System.out.println(y.equals(x)); //false - 대칭성 위배!

            List<CaseInsensitiveString> list = new ArrayList<>();
            list.add(x);
            System.out.println(list.contains(y)); //false
        }

    CaseInsensitiveString 의 equals 은 String 을 알고 있지만, String 의 equals 은 CaseInsensitiveString 을 모른다.
    이 문제를 해결하려면 CaseInsensitiveString 와 String 과 연동하겠다는 꿈을 버려라.

    public class CaseInsensitiveString {
        private String s;

        public CaseInsensitiveString(String s) {
            this.s = s;
        }

        @Override
        public boolean equals(Object o) {
            return (o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgnoreCase(s));

        }

        public static void main(String[] args) {
            CaseInsensitiveString x = new CaseInsensitiveString("Polish");
            String y = "polish";
            System.out.println(x.equals(y)); //false
            System.out.println(y.equals(x)); //false - 대칭성 일치!
    3.추이성
    추이성은 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.

    enum Color {
        RED, BLUE, BLACK, WHITE;
    }

    public class Point {
        private final int x;
        private final int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Point))
                return false;
            Point that = (Point) o;
            return that.x == x && that.y == y;
        }
    }

    class ColorPoint extends Point {
        private final Color color;

        public ColorPoint(int x, int y, Color color) {
            super(x, y);
            this.color = color;
        }

        //부모 클래스의 equals 을 오버라이드 하지만 color 은 비교하지 않게된다.
        public boolean equals(Object o) {
            if (!(o instanceof ColorPoint))
                return false;
            return super.equals(o) && ((ColorPoint) o).color == color;
        }

        public static void main(String[] args) {
            ColorPoint colorPoint = new ColorPoint(1, 2, Color.RED);
            Point point = new Point(1, 2);
            System.out.println(colorPoint.equals(point)); //false
            System.out.println(point.equals(colorPoint)); //true - 대칭성 위배!
        }
    }

    그렇다면 Point 인스턴스와 ColorPoint 인스턴스를 달리 동치성 비교를 해보자.
    public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;
        //o 가 Point 인스턴스라면 색상을 무시하고 비교한다.
        if (!(o instanceof ColorPoint))
            return super.equals(o);
        //ColorPoint 인스턴스라면 색상까지 비교한다.
        return super.equals(o) && ((ColorPoint) o).color == color;
    }

    public static void main(String[] args) {
        ColorPoint redPoint = new ColorPoint(1, 2, Color.RED);
        Point point = new Point(1, 2);
        ColorPoint bluePoint = new ColorPoint(1, 2, Color.BLUE);
        System.out.println(redPoint.equals(point)); //true
        System.out.println(point.equals(bluePoint)); //true
        System.out.println(redPoint.equals(bluePoint)); //false - 추이성 위배!
    }

    * 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.

    그렇다면 구체 클래스는 부모 클래스와 항상 논리적으로 동의하지 않는가?
    public class Point {
        private final int x;
        private final int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        //이렇게 하지 마라!
        @Override
        public boolean equals(Object o) {
            if (o == null || o.getClass() != getClass())
                return false;
            Point that = (Point) o;
            return that.x == x && that.y == y;
        }
    Point 의 하위 클래스는 정의상 여전히 Point 이므로 어디서든 Point 로써 활용되어야 한다.

    리스코프 치환 원칙?
        어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다. 따라서 그 타입의 모든 메서드가
        하위 타입에서도 똑같이 잘 작동해야 한다.
        이는 "Point 의 하위 클래스는 정의상 여전히 Point 이므로 어디서든 Point 로써 활용될 수 있어야 한다."

    public class Point {
        private final int x;
        private final int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            //클래스로 비교하므로 리코코프 치환 원칙(서브 클래스에선 동작하지 않음)을 위배.
            if (o == null || o.getClass() != getClass())
                return false;
            Point that = (Point) o;
            return that.x == x && that.y == y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }

    class CounterPoint extends Point {
        private static final AtomicInteger counter = new AtomicInteger();

        public CounterPoint(int x, int y) {
            super(x, y);
            counter.getAndIncrement();
        }

        public static int numberCreated() { return counter.get(); }
    }

    enum UnitCircle {
        instance;
        private static final Set<Point> unitCircle = new HashSet<>(Arrays.asList(new Point(1, 0), new Point(0, 1), new Point(-1, 0), new Point(0, -1)));

        public boolean onUnitCircle(Point p) {
            return unitCircle.contains(p);
        }
    }

     public static void main(String[] args) {
        System.out.println(UnitCircle.instance.onUnitCircle(new Point(1, 0))); //true
             System.out.println(UnitCircle.instance.onUnitCircle(new CounterPoint(1, 0))); //false 리스코프 치환 원칙 위배!
         }

    * 팁. 상속 대신 컴포지션을 사용하라.
    public class Point {
        private final int x;
        private final int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Point))
                return false;
            Point that = (Point) o;
            return that.x == x && that.y == y;
        }
    }

    class ColorPoint {
        private Point point;
        private Color color;

        public ColorPoint(int x, int y, Color color) {
            this.point = new Point(x, y);
            this.color = color;
        }

        /**
         * ColorPoint 의 Point 뷰를 리턴한다.
         * @return
         */
        public Point asPoint() {
            return point;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof ColorPoint))
                return false;
            ColorPoint that = (ColorPoint) o;
            return that.color.equals(color) && that.point.equals(point);
        }

        public static void main(String[] args) {
            //REFLEX
            ColorPoint cp = new ColorPoint(1, 2, Color.RED);
            ColorPoint cp2 = new ColorPoint(1, 2, Color.RED);
            ColorPoint cp3 = new ColorPoint(1, 2, Color.RED);
            Point p = new Point(1, 2);

            System.out.println(cp.equals(cp)); //true - 반사성 일치

            System.out.println(cp.equals(cp2)); //true
            System.out.println(cp2.equals(cp)); //true - 대칭성 일치
            System.out.println(cp.equals(p)); //false
            System.out.println(p.equals(cp)); //false- 대칭성 일치.

            System.out.println(cp.equals(p)); //false
            System.out.println(p.equals(cp2)); //false - ColorPoint 은 Point 을 상속하지 않았으므로 리스코프 원칙 위배하지 않음!
            System.out.println("View: " + cp.asPoint().equals(p)); //true
            System.out.println(cp2.equals(cp)); //true - 추이성 일치

            System.out.println(cp.equals(cp2)); //true
            System.out.println(cp2.equals(cp3)); //true
            System.out.println(cp.equals(cp3)); //true 추이성 일치
        }

    양질의 equals 구현 방법의 단계.
        1. == 연산자를 사용해 입력이 자기 자신의 참조인지를 확인한다. (성능 최적화).
        2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.
            정의된 클래스가 아닌 그 클래스가 구현한 특정 인터페이스를 통해 비교할 수 있다.
        3. 입력을 올바른 타입으로 형변환한다.
        4. "핵심" 필드들이 모두 일치하는지 하나씩 검사한다.

        * float 와 double을 제외한 기본 타입 필드는 == 연산자로 비교.
        * float 와 double은 Float.compare, Double.compare 로 비교.
        * 참조 타입 필드는 equals 로 비교.
        * 배열의 모든 원소가 핵심 필드라면 Arrays.eqauls 을 사용.
        * null 이 예상된다면 Objects.equals 을 통해 NullPointerException 을 ㅇ{방.
        * 비용이 싼 필드부터 비교해야 성능이 올라간다.
        * equals 을 다 구현했다면 세 가지만 자문해보자. 대칭적인가? 추이성이 있는가? 일관적인가?

        추가 사항.
        * equals 을 재정의할 땐 hashCode 도 반드시 재정의하라.
        * 너무 복잡하게 해결하려 들지 마라. 너무 공격적으로 파고들다가 문제가 일어난다.
        * Object 이외의 타입을 매개변수로 받는 equals 메서드를 선언하지 마라.

    import static com.google.common.base.Preconditions.checkArgument;

    public class PhoneNumber {
        private final short areaCode;
        private final short prefix;
        private final short lineNum;

        public PhoneNumber(short areaCode, short prefix, short lineNum) {
            checkArgument(areaCode > 0 && areaCode < 999);
            checkArgument(prefix > 0 && prefix < 999);
            checkArgument(lineNum > 0 && lineNum < 999);
            this.areaCode = areaCode;
            this.prefix = prefix;
            this.lineNum = lineNum;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this)
                return true;
            if (!(o instanceof PhoneNumber))
                return false;
            PhoneNumber p = (PhoneNumber) o;
            return p.areaCode == areaCode &&
                    p.prefix == prefix &&
                    p.lineNum == lineNum;
        }
    }

    핵심정리.
        꼭 필요한 경우가 아니면 equals 을 재정의하지 말자. 재정의해야 할 때는 클래스의 핵심 필드를 모두를 빠짐없이,
        다섯 가지 규약(반사성, 대칭성, 추이성, 일관성, null 아님) 지켜가며 비교하라.

equals 을 재정의하면 hashCode 도 재정의하라.
    Object 명세에 있는 HashCode 규약이다.
    1. equals 비교에 사용되는 핵심 필드가 변경되지 않았다면, 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 같은 값을 반환해야 한다.
    2. equals 로 두 객체를 같다고 판단했다면, 두 객체의 hashCode 은 똑같은 값을 반환해야 한다.
    3. equals 로 두 객체를 다르다고 판단하더라도, 두 객체의 hashCode 가 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서 다른 값을 반환해야 HashTable 의 성능이 좋아진다.

    이 중 "논리적으로 같은 객체"는 같은 hashCode 를 반환해야 한다는 규약이 가장 중요하다.

    hashCode 을 정의하지 않으면 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 Map 버킷에서 찾아오질 못한다.
    Map<PhoneNumber, String> m = new HashMap<>();
    m.put(new PhoneNumber(707, 867, 5309), "Jenny"); // null 반환


    @Override public int hashCode() { return 42; }
    해시테이블의 버킷 하나에 담겨 연결 리스트(Linked List) 처럼 동작.
    O(1) 인 해시테이블이 O(n) 으로 느려진다.

    다음은 좋은 hashCode을 작성하는 간단한 요링이다.
    1. int 변수 result 을 선언한 후 c 로 초기화한다. c 는 첫번째 핵심 필드를 2.a 방식으로 계산한 hashCode 이다.
        핵심 필드란 equals 비교에 사용된 필드.
    2. 해당 객체의 나머지 핵심 필드 f 각각에 다음 작업을 수행한다.
        2.a. 해당 필드의 해시코드 c를 계산한다.
            i. 기본 타입 필드라면, Type.hashCode(f) 를 수행한다. 여기서 나온 Type 은 해당 기본 타입의 박싱 클래스다.
            ii. 참조 타입 필드면서, 이 클래스의 equals 메서드가 이 필드의 equals 을 재귀적으로 호출해 비교한다면,
            이 필드의 hashCode 을 재귀적으로 호출.
            필드의 값이 null 이면 0을 사용한다.
            iii. 필드가 배일이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 배열에 핵심 원소가 하나도 없다면
            단순히 상수(0) 을 사용한다. 모든 원소가 핵심 원소라면 Arrays.hashCode 을 사용한다.
        b. 단계 2.a 에서 계산한 해시코드 c 로 result 을 갱신한다.
            result = 31 * result + c;
    3. result 을 반환.

    * 파생 필드 (다른 필드로부터 계산해낼 수 있는 필드는 무시 - 성능)
    * "equals" 비교에 사용되지 않은 필드는 "반드시" 제외.
    * 곱한 숫자 31로 정한 이유는 31이 홀수이면서 소수(prime) 이기 때문.
    * 곱한 숫자가 짝수이고 overflow 가 발생한다면 정보를 잃게 된다.
    * 31 * i 를 (i << 5) - i 로 치환함으로 성능상 이점을 발휘할 수 있다.

    @Override
    public int hashCode() {
        int result = 0;
        result = 31 * result + Integer.hashCode(areaCode);
        result = 31 * result + Integer.hashCode(prefix);
        result = 31 * result + Integer.hashCode(lineNum);
        return result;
    }

    @Override
    public int hashCode() {
        int result = Integer.hashCode(areaCode);
        result = (result << 5) - result + Integer.hashCode(prefix);
        result = (result << 5) - result + Integer.hashCode(lineNum);
        return result;
    }
    위 해시 제작 요령은 충분히 훌륭하니 믿고 사용하자.
    Objects.hash 은 입력 인수를 담기 위해 배열이 만들어지고, 입력 중 기본 타입이 있다면 박싱과 언박싱을 거치므로 속도가 느리다.

         public static int hash(Object... values) {
                return Arrays.hashCode(values);
         }

        public static int hashCode(Object a[]) {
            if (a == null)
                return 0;

            int result = 1;

            for (Object element : a)
                result = 31 * result + (element == null ? 0 : element.hashCode());

            return result;
        }
    해시 충돌이 적은 방법을 써야 한다면 com.google.common.hash.Hashing 을 사용하자.

    * 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 해시코드를 해시하는 방식을 고려하자.
    * 해시 성능을 높인다고 핵심 필드를 생략하면 해시 품질이 나빠져 해시테이블의 성능이 심각하게 떨어진다. 수 많은 인스턴스가 단 몇 개의 해시코드로 집중되어
    해시테이블의 속도가 선형으로 느려진다.

    핵심 정리.
        equals 을 재정의할 때는 hashCode 도 반드시 재정의하자. 재정의한 hashCode 은 Object 의 기술된 일반 규약을 따라야 하며,
        서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 Hash Collection 에서 성능 이점을 볼 수 있다.

toString 을 항상 재정의하라.
    Object 의 기본 toString은 "클래스이름@16진수로_표시한_해시코드(ex: PhoneNumber@abbd)" 처럼 적합한 문자열을 리턴하지 않는다.
    toString 의 일반 규약에 따르면 toString은 "간결하면서 사람이 읽기 쉬운 형태의 유익한 정보"를 반환해야 한다.
    toString 을 잘 구현한 클래스는 사용하기 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
    toString 메서드는 객체를 println, printf, 문자열 연결 연산자(+), assert 구문에 넘길때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다.
    toString 은 그 객체가 가진 주요 정보 모두를 반환하는게 좋다.

    Assertion failure: expected {abc, 123} but was {abc, 123}.
    // 주요 정보가 담기지 않았을 때 문제가 되는 ex.

    toString 을 비지니스 format 으로 사용하지 마라. 포맷을 한번 명시하면 평생 그 포맷에 얽매이게 된다.
    *정적 유틸리티 클래스, enum 은 toString 을 제공할 이유가 없다.

    핵심 정리.
        모든 구체 클래스에서 Object 의 toString 을 재정의하자. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외다.
        toString 을 재정의한 클래스는 사용하기 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다.
        toString 은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

clone 재정의는 주의해서 진행하라.
    Cloneable 인터페이스는 복제해도 되는 클래스임을 명시하는 용도의 인터페이스이다.
    문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이란 것이다.

     Cloneable 은 Object.clone 의 동작 방식을 결정한다.
     Cloneable 을 구현하지 않은 구현체의 clone 을 호출하면 CloneNotSupportedException 이 발생한다.
         * 잘못된 설계의 Cloenable.
         인터페이스를 구현한다는 것은 구현체가 해당 클래스가 인터페이스에 정의한 기능을 제공한다는 것이다.
         Cloneable 은 해당 인터페이스를 구현한 클래스의 상위 클래스 (Object)에 정의된 동장 방식을 변경하므로 설계가 잘못되었다.

     Cloneable 의 목적.
        Cloneable 을 구현한 클래스는 clone 메서드를 public 으로 제공하며, 클라이언트는 당연히 복제가 제대로 이뤄지리라 기대한다.
        Cloneable 은 생성자를 호출하지 않고도 객체를 생성시킨다.

    Cloneable 의 명세.
    어떤 객체에 대한 다음 식은 참이다
        1. x.clone() != x
        2. x.clone().getClass() == x.getClass()
        3. x.clone().equals(x)
        4. 관례상, 반환하는 객체는 super.clone 을 통해 얻어야 한다. 이 클래스와 모든 상위 클래스(Object 를 제외한) 모든 상위 클래스가 이 관례를 따라야 한다.

    Object.clone.
        Primitive 타입의 값만 복제된 다른 인스턴스 생성하여 리턴한다.

    clone 메서드 정의법.
        1. super.clone 을 호출한다.
        2. 모든 필드가 기본 타입이거나 불변 객체를 참조한다면 해당 객체는 완벽하다.
        3. 쓸데없는 복사를 지양한다면 clone 메서드를 제공하지 않는 게 좋다.

    @Override
    public PhoneNumber clone() {
        try {
            return (PhoneNumber) super.clone(); // 공변 반환 타입
        } catch (CloneNotSupportedException e) {
            throw new AssertionError(); // 일어날 수 없는 일이다.
        }
    }

    @Test
    public void testCloneable() {
        PhoneNumber x = PhoneNumber.of(647, 676, 0370);
        assertNotSame(x, x.clone());
        assertSame(x.getClass(), x.clone().getClass());
        assertEquals(x, x.clone());
    }

    다른 가변 객체를 참조한 클래스의 clone
    단순히 super.clone 을 호출하면 기본 타입을 제외한 가변 객체의 필드는 같은 인스턴스를 참조한다.
    아래의 Stack 의 clone 메서드를 제대로 정의하려면 스택 내부 정보를 복사해야 한다.
    * 배열을 복제할때는 배열의 clone 을 사용하라.
      배열의 clone 은 새로운 배열 인스턴스를 생성하여, 같은 element 을 담아 리턴한다.

    public class Stack {
        private int size;
        private Object[] elements;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;

        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(Object el) {
            ensureCapacity();
            elements[size++] = el;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            Object r = elements[--size];
            elements[size] = null;
            return r;
        }

        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }

    연결리스트와 clone.
        Hashtable 내부는 버킷들의 배열이고, 각 버킷은 키-값 쌍을 담는 연결 리스트의 첫 번째 Entry 을 참조한다.
        버킷 배열의 clone 을 호출하면 복제본 clone 을 같지만 복제된 버킷(연결리스트)의 Entry 은 Next Entry 로 같은 인스턴스를 참조한다.

        public class HashTable implements Cloneable {
            private Entry[] buckets; //bucket - Array of LinkedList

            private static class Entry {
                final Object key;
                Object value;
                Entry next;

                public Entry(Object key, Object value, Entry next) {
                    this.key = key;
                    this.value = value;
                    this.next = next;
                }
            }

            @Override
            public HashTable clone() {
                try {
                    HashTable r = (HashTable) super.clone();
                    r.buckets = buckets; //배열을 복재하지만, 가변 상태인 LinkedList 을 복제한다. 복제된 버킷은 LinkedList의 원본의 첫번째 Entry 를 참조한다.
                    return r;
                } catch (CloneNotSupportedException e) {
                    throw new AssertionError();
                }
            }
        }

        위를 해결하려면 각 버킷을 구성하는 연결 리스트를 복사해야 한다.
        public class HashTable implements Cloneable {
            private static Entry[] buckets;

            private static class Entry {
                private final Object key;
                private Object value;
                private Entry next;

                public Entry(Object key, Object value, Entry next) {
                    this.key = key;
                    this.value = value;
                    this.next = next;
                }

                Entry deepCopy() {
                    Entry r = new Entry(key, value, next);
                    for (Entry p = r; p.next != null;  p = p.next)
                        p.next = new Entry(p.next.key, p.next.value, p.next.next);
                    return r;
                }
            }

            public HashTable clone() {
                try {
                    HashTable r = (HashTable) super.clone();
                    r.buckets = new Entry[buckets.length];
                    for (int i = 0; i < buckets.length; i++)
                        r.buckets[i] = buckets[i].deepCopy();
                    return r;
                } catch (CloneNotSupportedException e) {
                    throw new AssertionError();
                }
            }

    복잡한 가변 객체를 복제하는 법.
        1. super.clone 을 호출하여 모든 필드를 초기 상태로 설정.
        2.원본 객체의 상태를 다시 생성하는 고수준 메서드를 호출. (위의 Hashtable 에서 buckets 필드를 새로운 버킷 배열로 초기화한 후,
        복제본 테이블의 Hashtable.put(key, value) -- 구현했다고 가정 -- 호출해 둘의 내용이 똑같에 해주면 된다.

    요약하자면, Cloneable 을 구현한 모든 클래스는 clone 을 재정의해야 한다.
    접근 제한자는 public, 반환 타입은 클래스 자신으로 변경한다.
    clone 을 정의시 먼저 super.clone 을 호출한 후 필요한 필드를 전부 적절히 수정한다.
    그 객체의 내부 "깊은 구조 ex) 내부 배열" 에 숨어 있는 모든 가변 객체를 복사하고, 원본 객체가 다른 참조를 가르킨다면 복제본이 가진 객체 참조 모두가 복사된 객체를 가리키도록 한다.

    핵심 정리.
    Cloneable 을 생성할 때는 위의 규칙을 잘 따라서 정의하자. 기본 원칙은 "복제 기능은 생성자와 팩토리를 이용하는게 최고" 이다.
    단, 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 예외라 할 수 있다.


Comparable을 구현할지 고려하라.
    compareTo 은 Object 의 메서드가 아닌 Comparable 의 메서드다.
    compareTo 은 단순 동치성 비교 (equals) 에 더해 순서까지 비교한다.
    compareTo 은 그 클래스에 대한 자연적인 순서 "natural order" 을 정의한다.

    Comparable 을 구현한 객체들의 배열은 Arrays.sort(a) 로 정렬할 수 있다.

    compareTo 의 일반 규약은 아래와 같다.
    1. 이 객체와 주어진 객체의 순서를 비교한다.
        a. 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0을, 크면 양의 정수를 반환.
        b. 비교할 수 없는 타입의 객체가 주어지면 ClassCastException 을 발생한다.
    sgn 표현식 표기론 아래와 같다.
        sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) 여야 한다.
        x.compareTo(y) > 0 && y.compareTo(z) > 0 라면 x.compareTo(z) > 0 여야 한다. (추이성)
        x.compareTo(y) == 0 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z)) 이여야 한다.
        x.compareTo(y) == 0 이라면 x.equals(y) 임을 권고한다. 만약 이 권고를 지키지 않는다면 그 사실을 명시해야 한다.

    * compareTo 의 규약은 equals 와 다르게 다른 타입 사이의 비교도 허용한다.
    compareTo 을 활용한 클래스의 예로는 정렬된 컬렉션인 TreeSet, TreeMap 과 검색과 정렬 알고리즘을 활용하는 유틸리티 클래스인 Collections 와 Arrays 가 있다.
    * 기존 클래스를 확장한 구체 클래스에서 새로운 값 컴포넌트를 추가했다면 compareTo 규약을 지킬 방법이 없다.
    * 위의 우회법도 같다. 확장하는 대신 독립된 클래스를 만들고, 이 클래스에 원래 클래스의 인스턴스를 가리키는 필드를 두고 뷰로써 리턴하면 같은 Class 라는 개념을 유지하면서 확장할 수 있다.

    equals 와 compareTo 가 다르게 구현됬을시 문제 사항.
    정렬된 컬렉션들은 동치성을 비교할 때 equals 대신 compareTo 을 사용한다.
    만약 BigDecimal 이 equals 와 compareTo 가 일관되지 않는 다면 HashTable 의 BigDecimal("1.0") 과 BigDecimal("1.00") 은 두 인스턴스로 존재하지만
    TreeSet 에선 원소를 하나만 갖게 된다.
    * 자연적인 순서가 아닌 순서는 Comparator 을 대신 사용한다.

    public class CaseInsensitiveString implements Comparable<CaseInsensitiveString> {
        private String s;

        public CaseInsensitiveString(String s) {
            this.s = s;
        }

        @Override
        public boolean equals(Object o) {
            return (o instanceof CaseInsensitiveString && ((CaseInsensitiveString) o).s.equalsIgnoreCase(s));
        }

        @Override
        public int compareTo(CaseInsensitiveString o) {
            return String.CASE_INSENSITIVE_ORDER.compare(s, o.s);
        }

    기본 타입 비교.
        항상 Number.compare 메서드를 사용하라. > 과 < 연산자는 거추장스럽고 오류를 남발한다.
     여러 핵심 필드를 비교할 시.
        어느 것을 가장 먼저 비교하냐가 중요하다.
        가장 핵심적인 필드부터 비교하며, 결과가 0이 아니라면 순서가 거기서 끝이니 바로 반환하자.
        똑같지 않은 필드를 찾을 때까지 그 다음으로 중요한 필드를 비교해간다.

    public int compareTo(PhoneNumber pn) {
        int r = Integer.compare(areaCode, pn.areaCode); // 가장 중요한 필드.
        if (r == 0) {   // 0이 아니라면
            r = Integer.compare(prefix, pn.prefix); // 두 번째로 중요한 필드
            if (r == 0) //0이 아니라면
                r = Integer.compare(lineNum, pn.lineNum); // 세 번째로 중요한 필드
        }
        return r;
    }

    Comparator 인터페이스의 비교자 생성 메서드.
        메서드 연쇄 방식으로 비교자를 생성한다. (10% 정도의 성능 저하가 따른다)
        comparingInt 은 키 추출 함수를 인자로 받는다.
    private static final Comparator<PhoneNumber> COMPARATOR = comparingInt(PhoneNumber::getAreaCode)
            .thenComparingInt(PhoneNumber::getPrefix)
            .thenComparingInt(PhoneNumber::getLineNum);

    public int compareTo(PhoneNumber pn) {
        return COMPARATOR.compare(this, pn);
    }

클래스와 멤버의 접근 권한을 최소화하라.
    잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.
    오직 API 를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다. (정보 은닉=캡슐화)

    정보 은닉의 장점.
     1. 시스템 개발 속도를 높인다. 병렬로 개발이 가능하다.
     2. 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 디버깅할 수 있으며, 교체도 용이하다.
     3. 정보 은닉은 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 해당 컴포넌트만 최적화가 가능하다.
     4. 소프트웨어 재사용성을 높인다. 외부에 의존하지 않고 독자적으로 동작하는 컴포넌트라면 낯선 환경에서도 쓰일 가능성이 크다.

     정보 은닉의 장치.
     접근 제어 메커니즘 (클래스, 인터페이스, 접근 제한자)

     클래스와 인터페이스의 접근 수준.
     public
        공개 API.
     package-private
        해당 패키지 안에서만 이요.
     * 패키지 외부에서 쓸 이유가 없다면 package-private 으로 선언하자.
     그러면 API가 아닌 내부 구현이 되어 언제든 수정할 수 있다.
     한번 public 으로 선언한다면 API가 되므로 하위 호환을 위해 영원히 관리해야 한다.
     내부 private static 클래스.
        바깥 클래스 하나에서만 접근할 수 있다.
     * 가장 먼저 할일은 해당 클래스가 외부에서 사용할 이유가 없다면 package-private 으로 공개 범위를 줄이자.
     이 후에 특정 클래스 하나만 접근해야 한다면 private static 클래스를 정의한다.

    멤버 필드 접근 수준.
    private
        멤버를 선언한 톱레벨 클래스에서만 접근.
    package-private
        멤버가 소속된 패키지 안의 모든 클래스에서 접근.
    protected
        package-private 의 접근 범위를 포함하여, 선언한 클래스의 하위 클래스에서도 접근.
    public
        모든 곳에서 접근
    * 클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private 으로 만들자.
    * public 클래스의 protected 와 public 멤버는 공개 API 이므로 영원히 지원해야 한다.
    * 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히는 것은 적당한 수준까진 괜찮다.

    public 클래스의 인스턴스 필드는 되도록 public (가변 필드)이 아니어야 한다.
        1. public 가변 필드이면 불변식을 보장할 수 없다.
        2. public 가변 필드를 가지는 클래스는 스레드에 안전하지 않다.

    클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해선 안된다.
    class Service {
        public static final Object[] VALUES = ...; // 보안 허점
    }

    class Other {
        static {
            Service.VALUES[0] = new Thing(); // 공개 API 와 다름 없다.
        }
    }

    배열을 public final static 으로 공개할때의 대안책.
    1. 배열을 PRIVATE 으로 만들고 불변 리스트를 공개한다.
    class Service {
        private static final Thing[] PRIVATE_VALUES = null;
        private static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
    2. 복사본을 반환하는 public 메서드를 반환한다.
    class Service {
        private static final Thing[] PRIVATE_VALUES = null;

        public static final Thing[] values() {
            return PRIVATE_VALUES.clone();
        }
    }

    핵심 정리.
    프로그램 요소의 접근성은 가능한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API을 설계하자.
    public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.
    public static final 필드가 참조하는 객체가 불변인지 확인하라.

public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
    아래 클래스는 정보 은닉의 이점을 제공받지 못한다. API 가 공개되었으므로 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며,
    외부에서 필드에 접근할 때 부수 작업을 수행할 수 없다.

    public class Point {
        public double x;
        public double y;
    }

    public 클래스 (공개 클래스) 라면 패키지 바깥에서 접근할 수 있게 접근자를 제공해야 한다.
    접근자를 제공함으로써 "내부 표현 방식을 언제든 바꿀 수 있는 유연성" 을 얻게 된다.

    public class Point {
        private double x;
        private double y;

        private Point(double x, double y) {
            this.x = x;
            this.y = y;
        }

        public static Point of(double x, double y) {
            checkArgument(x >= 0 && y >= 0);
            return new Point(x, y);
        }

        public double getX() {
            return x;
        }

        public double getY() {
            return y;
        }

        public void setX(double x) {
            this.x = x;
        }

        public void setY(double y) {
            this.y = y;
        }
    }

    package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출해도 괜찮다.
    이 방식은 클래스 선언 면에서나 클라이언트 코드 면에서나 접근자 방식보다 훨씬 깔끔하다.
    public 클래스의 필드가 불변이라도 공개하지 마라. API를 변경하지 않고는 표현 방식을 바꿀 수 없고,
    필드를 읽을 때 (ex. x 의 값이 바뀌면 특정 값에 따라 y 도 변경되야 한다) 부수 작업을 수행할 수 없다.

    핵심 정리.
    public 클래스는 절대 가변 필드를 노출해선 안된다. 불변 필드라도 노출하면 불이익이 따른다.
    하지만 package-private 클래스나 private 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

변경 가능성을 최소화하라.
    불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
    불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 덜대 달라지지 않는다.
    자바 플랫폼에는 String, 기본 타입의 박싱된 클래스, BinInteger, BigDecimal 이 여기 속한다.
    불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류의 여지도 적고 안전하다.

    불변 클래스 작성법.
    1. 클래스의 상태를 변경하는 메서드(setter) 을 제공하지 않는다.
    2. 클래스를 확장할 수 없게 한다.
    3. 모든 필드를 final 로 선언한다.
    4. 모든 필드를 private 으로 선언한다. (public 으로 공개하면 내부 표현을 변경할 수 없다.)
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없게 한다.
        클래스가 "가변 객체"를 참조하는 필드가 하나라도 있다면, 그 객체의 참조를 얻을 수 없게 한다.
        클라이언트가 제공된 객체 참조를 가리키게 해서는 안되며, 접근자 메서드(getter)가 그 필드를 반환하게 해서도 안 된다.
        제공된 객체의 내부 정보를 전달하기 위해선 "방어적 복사"를 수행하라.

    불변 클래스를 작성할 때, 필요한 기능은 함수를 제공하고 매번 새로운 인스턴스를 리턴하라.
    메서드의 이름은 동사 (add) 대신 전치사 (plus) 를 사용하라.
    불변 객체는 근본저긍로 스레드에 안전하여 synchronize 할 이유가 없다. (여러 스레드가 동시에 사용해도 절대 훼손되지 않는다)
    불변 클래스라면 한번 만든 인스터스를 "최대한 재활용" 하라.

    public final class Complex {
        private final double re;
        private final double im;

        private Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }

        public static Complex from(double re, double im) {
            return new Complex(re, im);
        }

        public double realPart() { return re; }

        public double imaginaryPart() { return im; }

        //자신은 수정하지 않고 새로운 인스턴스를 반환한다.
        public Complex plus(Complex c) {
            return from(re + c.re, im + c.im);
        }

        public Complex minus(Complex c) {
            return from(re - c.re, re - c.re);
        }

        public Complex times(Complex c) {
            return from(re * c.re - im * c.im, re * c.im + im * c.re);
        }

        public Complex dividedBy(Complex c) {
            double tmp = c.re * c.re + c.im * c.im;
            return from(((re*c.re + im*c.im) / tmp),
                    (im*c.re - re*c.im) / tmp);
        }

        @Override
        public boolean equals(Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Complex))
                return false;
            Complex c = (Complex) o;
            //double 과 float 타입의 필드는 Float.NaN, -0.0f, 특수한 부동소수 값 때문에 == 가 아닌 Double.compare 이용해 비교한다 (equals 부분 참조).
            return Double.compare(c.re, re) == 0 && Double.compare(c.im, im) == 0;
        }

        @Override
        public int hashCode() {
            return 31 * Double.hashCode(re) + Double.hashCode(im);
        }

        @Override
        public String toString() {
            return "(" + re + " + "  + im + "i)";
        }
    }

    불변 클래스를 캐쉬와 정적 팩토리를 이용하여 재활용하기.
    public final class Complex {
        public static final Complex ZERO = new Complex(0, 0);
        public static final Complex ONE = new Complex(1, 0);
        public static final Complex I = new Complex(0, 1);

        private final double re;
        private final double im;

        private Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }

        //불변 객체를 "캐쉬" 한 뒤 재사용하게끔 하여 메모리 사용량과 가비지 컬렉션 비용을 줄여라.
        public static Complex from(double re, double im) {
            if (re == 0 && im == 0)
                return ZERO;
            else if (re == 1 && im == 0)
                return ONE;
            else if (re == 0 && im == 1)
                return I;
            return new Complex(re, im);
        }

    불변 객체는 다른 객체의 구성요소로 사용되면 이점이 많다.
    불변 객체는 맵의 키와 집합의 원소로 쓰기에 안성맞춤인데, 가변 객체를 키로 쓴 경우 값이 바뀌면 Map 의 불변식이 허물어진다.

    불변 클래스의 단점.
    값이 다르면 반드시 독립된 객체로 만들어야 한다.
    BigInteger moby = ...;
    moby = moby.flatBit(0);

    불변 인스턴스를 생성하여 연산해야 할 때는 private 가변 동반 클래스를 생성하여 처리하라.
    ex) String (불변 클래스) - StringBuilder (가변 동반 클래스).

    불변 클래스의 상속을 막으려면 final 클래스 private 생성자와 대신 정적 팩토리를 제공하라. (flyweight 패턴을 이용한 캐쉬 이점)

    정리하자면, 클래스는 꼭 필요한 겨웅가 아니라면 불변이어야 한다.
    단순한 값 객체는 항상 불변으로 만들자.
    하지만 모든 클래스를 불변으로 만들 수 없다. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

상속보단 컴포지션을 사용하라.
    상속을 재사용하는 수단이지만, 최선은 아니다.
    상속은 캡슐화를 깨트린다.
        상위 클래스의 내부 구현의 변경으로 변경에 따라서 하위 클래스의 동작에 이상이 생길 수 있다.

    public class InstrumentedHashSet<E> extends HashSet<E> {
        private int addCount = 0;

        public InstrumentedHashSet() {}

        public InstrumentedHashSet(int initCap, float loadFactor) {
            super(initCap, loadFactor);
        }

        @Override
        public boolean add(E e) {
            addCount++;
            return super.add(e);
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            addCount += c.size();
            return super.addAll(c); //내부적으로 HashSet 이 add 함수를 호출하므로 예상대로 동작하지 않는다.
        }

        public int getAddCount() {
            return addCount;
        }
    }

    InstrumentedHashSet<Integer> set = new InstrumentedHashSet<>();
    set.addAll(Arrays.asList(1, 2, 3, 4));
    set.getAddCount(); //8

    만약 addAll 의 addCount += c.size() 을 코드를 지운다면 지금 순간은 제대로 동작할지 모르나,
    부모 클래스의 내부 구현을 알고 있다는 가정한 해법이므로 캡슐화가 무너진다.

    즉, 부모 클래스의 메서드 정의, 추가는 예상치 못한 서브 클래스의 동작 이상을 발생시킨다.
    이 문제를 해결하기 위해선 컴포지션(composition) 을 이용해 부모 클래스의 동작을 확장한다.

    구성 (Composition)
        기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조한다.
        기존 클래스가 새로운 클래스의 구성요소로 쓰인다해서 구성(composition) 이라 한다.
        새 클래스의 인스턴스 메서드는 기존 클래스의 대응하는 메서드 호출(forwarding) 이라 한다.
        구성은 새로운 클래스가 기존 클래스의 내부 구현 방식의 영향에서 벗어나며, 기존 클래스에 새로운 메서드가 추가되도
        전혀 연향받지 않는다.

    재사용할 수 있는 전달(forwarding) 클래스
    public class ForwardingSet<E> implements Set<E> {
        private final Set<E> s;

        public ForwardingSet(Set<E> s) {
            this.s = s;
        }

        @Override
        public int size() {
            return s.size();
        }

        @Override
        public boolean isEmpty() {
            return s.isEmpty();
        }

        @Override
        public boolean contains(Object o) {
            return s.contains(o);
        }

        @Override
        public Iterator<E> iterator() {
            return s.iterator();
        }

        @Override
        public Object[] toArray() {
            return s.toArray();
        }

        @Override
        public <T> T[] toArray(T[] a) {
            return s.toArray(a);
        }

        @Override
        public boolean add(E e) {
            return s.add(e);
        }

        @Override
        public boolean remove(Object o) {
            return s.remove(o);
        }

        @Override
        public boolean containsAll(Collection<?> c) {
            return s.containsAll(c);
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            return s.addAll(c);
        }

        @Override
        public boolean retainAll(Collection<?> c) {
            return s.retainAll(c);
        }

        @Override
        public boolean removeAll(Collection<?> c) {
            return s.removeAll(c);
        }

        @Override
        public void clear() {
            s.clear();
        }
    }

    구성(Composition) 을 통한 확장.
    public class InstrumentedSet<E> extends ForwardingSet<E> {
        private int addCount = 0;

        public InstrumentedSet(Set<E> s) {
            super(s);
        }

        @Override
        public boolean add(E e) {
            addCount++;
            return super.add(e);
        }

        @Override
        public boolean addAll(Collection<? extends E> c) {
            addCount += c.size();
            return super.addAll(c);
        }

        public int getAddCount() {
            return addCount;
        }

        public static void main(String[] args) {
            InstrumentedSet<Integer> set = new InstrumentedSet(new HashSet<>()); //HashSet 의 내부 구현의 영향을 받지 않는다.
            set.addAll(Arrays.asList(1, 2, 3, 4));
            System.out.println(set.getAddCount()); //4 제대로 작동한다!
        }
    }

    Set 인터페이스를 구현했고, Set의 인스턴스를 인수로 받는 생성자를 제공한다.
    Set에 새로운 기능을 덧씌워(decorate) 새로운 Set으로 만드는 것이 핵심이다.

    static void walk(Set<Dog> dogs) {
        InstrumentedSet<Dog> iDogs = new InstrumentedSet<>(dogs);
        //특정 조건하에서만 임시로 사용할 수 있다.
    }

    Wrapper 클래스.
        실제 기능을 구현한 인스턴스를 감싸고(wrap) 있는 클래스를 Wrapper 클래스라 한다.
        다른 인스턴스의 기능을 덧씌운다(확장) 한다는 뜻에서 Decorator Pattern 이라도 불린다.
        래퍼 클래스는 성능에 영향을 주지도 않고, 전달 메서드들을 전달한 클래스(위임 역할)은 재사용할 수 있으므로 작성하는 데 지루하지 않다.
        Guava 는 모든 컬렉션 인터페이스용 전달 메서드를 구현한다.

    상속과 구성의 선택법.
        상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 써라. A is a B.
        컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출한다.
        java.util.Properties 은 java.util.HashMap 을 상속했으면 안됬다.

    핵심 정리.
        상속은 강력하지만 캡슐화를 해친다. 상속은 상위 클래스와 하위 클래스가 is-a 관계일때만 써야 하며, 하위 클래스는 상위 클래스와
        패키지가 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 문제가 될 수 있다.
        상속의 취약점을 필요하면 Composition 과 Forwarding(혹은 위임) 을 사용하자.
        Wrapper 클래스는 하위 클래스보다 견고하고 강력하다.

상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
    상속 클래스를 설계시, 하위 클래스에서 해당 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서화하라.
    상속용 클래스는 재정의할 수 있는 메서드들(private 이 아닌 메서드)을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

      /**
         * {@inheritDoc}
         *
         * <p>This implementation iterates over the collection looking for the
         * specified element.  If it finds the element, it removes the element
         * from the collection using the iterator's remove method.
         *
         * <p>Note that this implementation throws an
         * <tt>UnsupportedOperationException</tt> if the iterator returned by this
         * collection's iterator method does not implement the <tt>remove</tt>
         * method and this collection contains the specified object.
         *
         * @throws UnsupportedOperationException {@inheritDoc}
         * @throws ClassCastException            {@inheritDoc}
         * @throws NullPointerException          {@inheritDoc}
         */
        public boolean remove(Object o) {

    {@inheritDoc} + CRTL + Q
        부모 클래스의 주석을 상속 받는다.
    {@implSpec}
        해당 클래스를 상속하여 메서드 재정의시 필요한 요구 상황을 상속 클래스를 작성한 자가 작성할 때 사용.

    내부 문서 남기는 것뿐만 아니라 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook) 을 잘 선별하여
    protected 메서드 형태로 공개해야 할 수 있어야 한다.
    아래 removeRange 은 clear 의 hook 으로 사용되며 서브 클래스에 공개(protected) 되었다.

     /**
         * Removes from this list all of the elements whose index is between
         * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
         * Shifts any succeeding elements to the left (reduces their index).
         * This call shortens the list by {@code (toIndex - fromIndex)} elements.
         * (If {@code toIndex==fromIndex}, this operation has no effect.)
         *
         * <p>This method is called by the {@code clear} operation on this list
         * and its subLists.  Overriding this method to take advantage of
         * the internals of the list implementation can <i>substantially</i>
         * improve the performance of the {@code clear} operation on this list
         * and its subLists.
         *
         * <p>This implementation gets a list iterator positioned before
         * {@code fromIndex}, and repeatedly calls {@code ListIterator.next}
         * followed by {@code ListIterator.remove} until the entire range has
         * been removed.  <b>Note: if {@code ListIterator.remove} requires linear
         * time, this implementation requires quadratic time.</b>
         *
         * @param fromIndex index of first element to be removed
         * @param toIndex index after last element to be removed
         */
        protected void removeRange(int fromIndex, int toIndex) {
            ListIterator<E> it = listIterator(fromIndex);
            for (int i=0, n=toIndex-fromIndex; i<n; i++) {
                it.next();
                it.remove();
            }
        }

    상속용 클래스를 설계할 때 어떤 메서드를 protected 로 노출해야 할 까?
        정답은 없다. 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. (설계는 고려하되, 두려워하지 말자. 그러면 늘질 못한다)
        상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 "유일"하다.
        반대로 작성하면서 제대로 아래 방법으로 설계됬는지 알 수 있다.
            꼭 필요한 "protected 멤버" 를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리고 확연히 드러난다.
            반대로, 전혀 쓰이지 않는 "protected 멤버" 는 "private 멤버" 였어야 할 가능성이 크다.

    상속 클래스 설계시 금기사항.
    상속용 클래스의 생성자는 직접, 간접적으로든 재정의 가능 메서드를 호출해선 안 된다.
        상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다.
        즉 상위 인스턴스가 먼저 생성되며, 재정의 가능 메서드를 호출하고 그 메서드가 하위 클래스의 초기화하는 값에 의존한다면
        의도대로 동작하지 않는다.

    public class Super {

        //잘못된 예 - 생성자가 재정의 가능 메서드를 호출
        public Super() {
            overrideMe(); // Sub 의 인스턴스가 생성(Sub의 생성자 호출)하기도 전에 재정의 가능한 메서드 호출한다.
        }

        protected void overrideMe() {
        }

        public static void main(String[] args) {
            Sub sub = new Sub();
            sub.overrideMe();
            //null
            //2019-07-18T23:12:14.454Z
        }
    }

    final class Sub extends Super {
        private final Instant instant;

        Sub() {
            instant = Instant.now();
        }

        @Override
        protected void overrideMe() {
            System.out.println(instant);
        }
    }

    상속용 클래스의 설계는 엄청난 노력이 들고 그 클래스에도 안기는 제약도 상당하다.
    또한 상위 클래스에 변화가 생길 때마다 하위 클래스가 오작동을 발생할 수 있다.
    이 문제를 해결하는 가장 좋은 방법은 상속용으로 충분히 설계되지 않은 클래스는 상속을 금지하는 것이다.
    상속을 금지하는 방법.
        모든 생성자를 private 로 선언하고 public 정적 팩토리를 구현.
        해당 클래스를 final 로 선언.
    만약 상속을 "꼭" 해야된다면.
        상속 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만든다. (재정의 가능 메서드를 호출하는 self 사용 코드를 완전히 제거)

    핵심 정리.
        상속용 클래스를 설계하기란 결코 만만치 않다.
        클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
        다른 이가 효율 좋은 하위 클래스를 만들 기 위해 일부 메서드를 protected 로 제공해야 할 수 있다.
        그러나 확장해야 할 명확한 이유가 없다면 상속을 금지하라.

인터페이스는 구현하는 쪽을 생각해 설계하라.
    자바 8에서는 디폴트 메서드가 추가되었다. 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은
    모든 클래스에선 디폴트 구현이 쓰이게 된다.
    하지만 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.

    자바 8에 추가된 Collection 인터페이스의 removeIf
    /**
     * Removes all of the elements of this collection that satisfy the given
     * predicate.  Errors or runtime exceptions thrown during iteration or by
     * the predicate are relayed to the caller.
     *
     * @implSpec
     * The default implementation traverses all elements of the collection using
     * its {@link #iterator}.  Each matching element is removed using
     * {@link Iterator#remove()}.  If the collection's iterator does not
     * support removal then an {@code UnsupportedOperationException} will be
     * thrown on the first matching element.
     *
     * @param filter a predicate which returns {@code true} for elements to be
     *        removed
     * @return {@code true} if any elements were removed
     * @throws NullPointerException if the specified filter is null
     * @throws UnsupportedOperationException if elements cannot be removed
     *         from this collection.  Implementations may throw this exception if a
     *         matching element cannot be removed or if, in general, removal is not
     *         supported.
     * @since 1.8
     */
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }

    디폴트 메서드를 추가한 후 아파치의 SynchronizedCollection 의 removeIf 은 디폴트 메서드를 그대로 사용한다.
    이때 동기화를 해주겠다는 클래스의 약속을 지키지 못하므로 예기치 못한 결과로 이어질 수 있다.
    즉 디폴트 메서드의 추가는 기존에 짜여진 많은 자바 크드가 영향을 준다.

    핵심 정리.
    디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.

인터페이스는 타입을 정의하는 용도로만 사용하라.
    인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다.
    반대로, 클래스가 어떤 인터페이스를 구현했다는 것은 자신의 인스턴스로 무엇을 할 수 있는지 클라이언트에게 얘기해주는 것.

    클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당한다.
    //상수 인스터페이스 안티패턴
    public interface PhysicalConstants {
        static final double AVOGADROS_NUMBER = 6.022_140_857e23;
        static final double BOLTZMANN_CONSTANT = 1.380_648_52e23;
        static final double ELECTRON_MASS = 9.109_383_56e-31; //tip 숫자를 정의할 땐 3 자리씩 묶어서 _ 을 붙여주면 가독성이 좋아진다.
    }
    상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API 로 노출하는 행위다. (캡슐화 위반)
    클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속된다.

    상수를 공개할 목적이라면 상수 인터페이스를 사용하지 말고 그 상수와 강하게 연관된 클래스나 인터페이스 자체에 추가하라.
    - 인터페이스의 용도로 상수 정의 목적을 쓰지말자, 쓸 거면 싱글톤 Util 클래스를 생성해서 정의하라.

    핵심 정리.
    인터페이스는 타입을 정의하는 용도로 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.

태그 달린 클래스보다는 클래스 계층구조를 활용하라.
    태그 달린 클래스는 여러 구현이 한 클래스에 혼합돼 있어서 코드가 복잡하고 가독성도 나쁘다.
    또한 태그에 따라 사용되지 않는 필드 때문에 (사용되지 않더라도 초기화시 메모리 공간이 할당) 메모리도 많이 사용한다.
    새로운 태그를 추가할 때마다 코드도 추가해야 되는데, 하나라도 빠트리면 런타임 에러가 발생한다.
    인스턴스 타입만으로는 현재 나타내는 상태를 알 길이 없다.
    즉, 태그 달린 클래스는 장황하고, 오류 내기 쉽고, 비효율적이다.

    //태그 달린 클래스 - 클래스 계층구조보다 훨씬 나쁘다.
    class Figure {
        enum Shape { RECTANGLE, CIRCLE }

        //태그 필드 - 현재 모양을 나타낸다.
        final Shape shape;

        //다음 필드는 모양이 사각형(RECTANGLE) 일 때만 쓰인다.
        double length;
        double width;

        //다음 필드는 모양이 원(CIRCLE) 일 때만 쓰인다.
        double radius;

        Figure(double radius) {
            shape = Shape.CIRCLE;
            this.radius = radius;
        }

        Figure(double length, double width) {
            shape = Shape.RECTANGLE;
            this.length = length;
            this.width = width;
        }

        double area() {
            switch (shape) {
                case RECTANGLE:
                    return length * width;
                case CIRCLE:
                    return Math.PI * (radius * radius);
                default:
                    throw new AssertionError(shape);
            }
        }
    }

    태그 달린 클래스를 클래스 계층구조로 바꾸는 방법.
    Root 가 될 추상 클래스를 정의하고, 태그 값에 따라 달라지는 메서드들(주로 switch, if 문에서 태그를 사용) 을 추상 메서드로 선언.
    그런 다음 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클레스에 일반 메서드로 추가.


    //클래스 계층구조로 변환. 훨씬 간결하고 명확하며, 쓸데없는 코드가 모두 사라졌다.
    //반대로 모든 클래스가 하나의 책임을 가진다. (Single Responsibility)
    abstract class Figure {
        abstract double area();
    }

    class Rectangle extends Figure {
        final double length;
        final double width;

        public Rectangle(double length, double width) {
            this.length = length;
            this.width = width;
        }

        @Override
        double area() {
            return length * width;
        }
    }

    class Circle extends Figure {
        final double radius;

        public Circle(double radius) {
            this.radius = radius;
        }

        @Override
        double area() {
            return Math.PI * (radius * radius);
        }
    }

    정사각형을 추가한다고 한다면 계층구조를 통해 쉽게 코드를 재사용하며 클래스를 정의할 수 있다.

    class Square extends Rectangle {
        Square(double side) {
            super(side, side);
        }
    }

    핵심 정리.
    태그 달린 클래스를 써야 하는 상황은 거의 없다. 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고
    계층구조로 대체하는 방법을 생각해보자. 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩토링하는 걸 고민해보자.

멤버 클래스는 되도록 static 으로 만들라.
    중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다.
    중첩 클래스는 자신을 감싼 바깥 클래스에마서만 쓰여야 한다.
    중첩 클래스 != 내부 클래스

    중첩 클래스의 종류.
    1. 정적 멤버 클래스.
    2. 멤버 클래스.
    3. 익명 클래스.
    4. 지역 클래스.

    첫 번째를 제외한 나머지는 내부 클래스(inner class) 에 해당.

    정적 멤버 클래스.
        정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에 접근 가능한다는 점만 제외하고
        일반 클래스와 똑같다.

    정적 클래스와 비정적 멤버 클래스의 차이.
        비정적 멤버 클래스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다.
        비정적 멤버 클래스의 인스턴스 메서드에서this 을 사용해 바깥 인스턴스의 메서드를 호출하거나 참조 (클래스명.this) 를 가져올 수 있다.
        비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없지만 정적 멤버 클래스는 바깥 인스턴스와 관계없이 독립적으로 존재 가능.
        비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다. (map 의 keySet, entrySet)
        비정적 멤버 클래스는 바깥과 내부 참조 정보를 저장하기에 시간과 공간이 소비된다.
        비정적 멤버 클래스는 내부 참조때문에 바깥 참조의 인스턴스가 가비지 컬렉터에 회수되지 못하 메모리 누수가 생길 수 있다.

    *어댑터?
        어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰를 생성하는 패턴.

    abstract class HashIterator {
        Node<K,V> next;        // next entry to return
        Node<K,V> current;     // current entry
        int expectedModCount;  // for fast-fail
        int index;             // current slot

        HashIterator() {
            expectedModCount = modCount; //바깥 인스턴스의 프러퍼티
            Node<K,V>[] t = table;
            current = next = null;
            index = 0;
            if (t != null && size > 0) { // advance to first entry
                do {} while (index < t.length && (next = t[index++]) == null);
            }
        }

        public final boolean hasNext() {
            return next != null;
        }

        final Node<K,V> nextNode() {

     멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static 을 붙여 정적 멤버 클래스 만들어라.
     private 정적 멤버 클래스는 바깥 클래스가 표현하는 객체의 한 부분(구성요소) 을 나타낼 때 쓴다.
     Map 의 Entry 은 Map 구현체의 키-값 쌍을 표현하는 Entry (구성요소) 를 표현하지만 Entry 은 맵을 직정 사용하지 않는다.
     따라서 Entry 을 비정적 멤버 클래스로 표현하는 것은 낭비고 static 으로 선언하는 것이 맞다.

     핵심 정리.
     중첩 클래스에는 네 가지가 있으며, 각각의 쓰임이 다르다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔
     너무 길다면 멤버 클래스로 만든다. 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않으면 정적으로 만들어라.
     익명 클래스와 지역 클래스는 람다로 대체하자.

제네릭.
    제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다.
    * 따라서 컴파일러는 알아서 형변환 코드를 추가하고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서 차단한다.

    제네릭 용어 정리.
    type parameter = parameterized type. 클래스와 인터페이스 선언에 사용된 타입 매개변수.
    generic class. 클래스와 인터페이스 선언에 type parameter 가 사용된 클래스.  (ex List<E>)
        GenericClass<String> g = new GenericClass<>();
        for (TypeVariable type: g.getClass().getTypeParameters()) { //type parameter 을 가져온다.
            System.out.println(type);
        }
    raw type - 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용핮 않을 때. (ex. List<E> 의 로 타입은 List)

Raw 타입은 사용하지 마라.

    Raw 타입 제네릭을 사용하면 다른 타입의 클래스를 컬렉션에 넣어도 컴파일되고 실행된다.
    컬렉션에서 이 동전을 다시 꺼내기 전에는 오류를 알아차리지 못한다.
    오류는 가능한 발생 즉시, 이상적으로는 컴파일할 때 발견되는 것이 좋다.

    //Stamp 인스턴스만 취급한다.
    //컬렉션 raw type. 따라하지 말 것.
    private static final Collection stamps =
        Arrays.asList(new Stamp(), new Stamp(), new Stamp(), new Coin());

    for (Iterator i = stamps.iterator(); i.hasNext(); ) {
        Stamp stamp = (Stamp) i.next(); //ClassCastException
        stamp.cancel();
    }

    제네릭을 활용하면 이 정보가 주석이 아닌 타입 선언 자체에 녹아든다.
    private static final Collection<Stamp> stamps =
        Arrays.asList(new Stamp(), new Stamp(), new Stamp(), new Coin()); // 컴파일 에러

    로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.

    List 은 안되지만 List<Object> 는 괜찮다.
    List<Object> 은 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것.
    메서드에 매개변수로 List<String> 을 전달받은 메서드에 List<String> 은 괜찮지만 List<Object> 은 넘길 수 없다. (제네릭 하위 타입 규칙)

    제네릭 하위 타입 규칙.
    List<String> 은 List 의 하위 타입.
    List<String> 은 List<Object> 의 하위 타입 아님.

    List<String> strings = new ArrayList<>();
    unsafeAdd(strings, Integer.valueOf(42));
    unsafeAdd2(strings, Integer.valueOf(42)); // 하위 타입 규칙 위반

    private static void unsafeAdd(List list, Object o) { //strings 은 list 의 하위 타입.
        list.add(o);
    }

    private static void unsafeAdd2(List<Object> list, Object o) { //strings 은 list<Object> 의 하위 타입 아님.
        list.add(o);
    }

    제네릭의 원소의 타입을 모를때의 대안 방법.
    비한정적 와일드카드 타입(unbounded wildcard type) 을 대신 사용.

    비한정적 와일드 카드(unbounded wildcard type)
    List<Number> 은 List<Integer> 의 상위 타입이 아니다. (List<String> 과 List<Object> 의 관계와 같음)
    List<Integer> list = Arrays.asList(1, 2, 3);
    List<Number> l = list; // 컴파일 에러
    List<Integer> l2 = list;

    제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?) 을 사용.
    물음표(?) 은 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수.

    로 타입을 잘못 사용한 예.
    static int numElementsInCommon(Set s1, Set s2) {
        int r = 0;
        for (Object o: s1)
            if (s2.contains(o))
                r++;
        return r;
    }

    static int numElementsInCommon(Set<?> s1, Set<?> s2) {
        int r = 0;
        for (Object o: s1)
            if (s2.contains(o))
                r++;
        return r;
    }

    로 타입과 와일드 카드 타입(unbounded wildcard type) 의 차이점.
    와일드 카드 타입은 null 외에는 어떤 원소도 넣을 수 없으므로 (cast 예외 생기지 않음) 안전. (타입 불변식 보존)
    이러한 제약을 받아들일 수 없다면 제네릭 메서드 혹은 한정적 와일드카드 타입을 사용.

    로 타입의 사용처.
    class 리터럴에는 로 타입을 사용.
    List.class 은 허용.
    List<String>.class, List<?>.class 불허용.

    instanceof 연산자는 매개변수화 타입에는 적용할 수 없다.
    즉, 로 타입이든 비한정적 와일드카드 타입이든 instanceof 는 똑같이 동작.

    Object o = new HashSet<>(Arrays.asList(1, 2, 3));
    if (o instanceof Set) { // instanceof 을 로 타입으로 체크
        Set<?> s = (Set<?>) o; // 주의! 로타입을 사용하지마라.
        ...
    }

    핵심 정리.
    로 타입을 사용하면 런타임 예외가 발생할 수 있으니 사용하지 마라.
    Set<Object> 은 어떤 타입의 객체도 저장할 수 있는 "매개변수화 타입" 이고,
    Set<?> 은 모종의 타입 객체만 저장할 수 있는 "와일드카드 타입"이다.
    로 타입 Set 은 제네릭 타입 시스템에 속하지 않는다.
    Set<Object>, Set<?> 은 안전하지만, Set 은 안전하지 않다.

제네릭 용어 정리
    parameterized type (매개변수화 타입)   - List<String>
    generic type (제네릭 타입)   - List<E>
    raw type    (로 타입)  - List

    actual type parameter (실제 타입 매개변수)  - String
    formal type parameter (정규 타입 매개변수)  - E
    bounded type parameter (한정적 타입 매개변수) - <E extends Number>
    recursive type bound (재귀적 타입 한정) - <T extends Comparable<T>>
    unbounded wildcard type (와일드 카드 타입) - List<?>
    bounded wildcard type (한정적 와일드 카드 타입) - List<? extends Number>

    generic method (제네릭 메서드) - static <E> List<E> asList(E[] a)
    type token  (타입 토큰) - String.class

비검사 경고를 제거하자.
    제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 될 것이다.
    대부분의 비검사 경고는 쉽게 제거할 수 있다.

    Set<Lark> exaltation = new HashSet();
    //Note: Lark.java uses unchecked or unsafe operations.
    //Note: Recompile with -Xlint:unchecked for details.

    Set<Lark> exaltation = new HashSet<>(); //다이아몬드 연산자(<>) 을 사용하며 실제 타입 추론하여 경고를 없앰.

    할 수 있는 한 모든 비검사 경고를 제거하라.
    경고를 제거할 수 없지만 타입 안전하다고 확신할 수 있다면 @SuppressWarnings("unchecked") 어노테이션을 달아 경고를 숨겨라.
    단, 타입 안전함을 검증하지 않으면 경고 없이 컴파일되겠지만, 런타임에는 여전히 ClassCastException 이 던질 수 있다. (로 타입을 사용하지 마라)
    반대로, 비검사 경고를 그대로 두면, 진짜 문제를 알리는 경고가 나와도 눈치채지 못한다.

    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // Make a new array of a's runtime type, but my contents:
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    @SuppressWarnings 은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다.
    @SuppressWarnings 어노테이션은 항상 가능한 좁은 범위에 적용하자.

    <T> T[] toArray(T[] a) {
        if (a.length < size) {
            @SuppressWarnings("unchecked")
            T[] result = (T[]) Arrays.copyOf(this.elements, size, a.getClass());
            return result;
        }
        System.arraycopy(elements, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    핵심 정리.
    비검사 경고는 중요하니 무시하지 말자. 모든 비검사 경고는 런타임에 ClassCastException 을 일으킬 수 있는
    잠재적 가능성을 뜻하니 최선을 다해 제거하라. 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 안전함을 증명하고 가능한 범위를 좁혀
    @SuppressWarnings("unchecked") 어노테이션으로 경고를 숨겨라.

배열보다는 리스트를 사용하라.
    배열과 제니릭 타입에는 중요한 차이가 두 가지가 있다.
    배열은 공변(covariant) 이다.
    Sub 가 Super 의 하위 타입이라면 배열 Sub[] 은 배열 Super[] 의 하위 타입이다.

    제네릭은 불공변(invariant) 이다.
    서로 다른 타입 Type1 과 Typ2 가 있을 때, List<Type1> 은 List<Type2> 의 하위 타입도 아니고 상위 타입도 아니다.
    이 상황에서 문제가 생기는 쪽은 배열이다.

    Long[] array = new Long[1];
    if (array instanceof Object[])
        System.out.println("hey");
    Object[] refArray = array;
    refArray[0] = "Hi"; //ArrayStoreException

    List<Object> ol = new ArrayList<Long>(); //호환되지 않는 타입이다.
    ol.add("Hi");

    배열은 실체화 된다.
    즉, 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
    반면 제네릭은 타입 정보가 런타임에 소거된다.
    즉, 제네릭은 원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수 없다.

    배열은 제네릭 타입(List<E>), 매개변수화 타입(List<String>), 타입 매개변수(E) 로 사용할 수 없다.
    List<String>[] stringLists = new List<String>[1]; //Generic array creation is not allowed


    static class Chooser {
        private final Object[] choiceArray;

        public Chooser(Collection choices) {
            this.choiceArray = choices.toArray();
        }

        //타입 형변환을 해야 되며, 다른 원소가 있었다면 런타임에 형변환 오류가 발생.
        public Object choose() {
            Random rnd = ThreadLocalRandom.current();
            return choiceArray[rnd.nextInt(choiceArray.length)];
        }
    }

    static class Chooser<T> {
        private final T[] choiceArray;

        public Chooser(Collection<T> choices) {
            //this.choiceArray = choices.toArray(new T[0]); // 제네릭 배열은 생성할 수 없다.
            this.choiceArray = (T[]) choices.toArray(); //이 형변환이 런타임에 안전한지 보장할 수 없다.
        }
    }

    static class Chooser<T> {
        private final List<T> choiceList;

        public Chooser(List<T> choiceList) {
            this.choiceList = new ArrayList<>(choiceList); //List을 사용하면 오류나 경고 없이 컴파일 된다. T[] 보다 훨씬 타입에 안전하다.
        }
    }

    핵심 정리.
    배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
    배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가  소거돈다.
    그 결과 배열은 런타임에 타입 안전하지만 컴파일타임에는 그렇지 않다. 제네릭은 반대다.
    둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하자.

이왕이면 제네릭 타입으로 만들어라.
    제네릭을 사용하는 일은 쉬운 편이지만, 제네릭 타입을 새로 만드는 일은 조금 어렵다.
    하지만 배워두면 그만한 값어치는 충분히 한다.

    아래 클래스는 Object 을 element 로 사용하는 클래스다.
    지금 상태에서는 클라이언트는 스택에서 꺼낸 객체를 형변화해야 하는데, 런타임 오류가 생길 위험이 있다.

    //제네릭이 절실한 강력 후보.
    public class Stack {
        private Object[] elements;
        private int size;
        public static final int DEFAULT_INITIAL_CAPACITY = 16;

        public Stack() {
            this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(Object el) {
            ensureCapacity();
            elements[size++] = el;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            Object r = elements[--size];
            elements[size] = null; // 다 쓴 참조 해제.
            return r;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, size * 2 + 1);
        }
    }

    일반 클래스를 제네릭 클래스로 변경하기.
    1. 타입 매개 변수를 추가한다. 이때 타입 이름으로는 보통 E을 사용한다.
    2. 배열을 사용하는 코드라면, E 와 같은 실체화 불가 타입으로 만들 수 없으므로 아래 방법을 사용하여 문제를 해결한다.

    public class Stack<E> {
        private E[] elements;
        private int size;
        public static final int DEFAULT_INITIAL_CAPACITY = 16;

        //배열 elements 은 push(E) 로 넘어온 E 인스턴스만 담는다.
        //따라서 타입 안전성을 보장하지만,
        //이 배열의 런타임 타입은 E[] 가 아닌 Object[] 다!
        @SuppressWarnings("unchecked")
        public Stack() {
            //elements 은 private 이며 클라이언트에 전달되지 않으므로 비검사 형변환은 확실히 안전한다.
            //SuppressWarnings 으로 비검사 예외를 제거하라.
            this.elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(E el) {
            ensureCapacity();
            elements[size++] = el;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            E r = elements[--size];
            elements[size] = null; // 다 쓴 참조 해제.
            return r;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        private void ensureCapacity() {
                if (elements.length == size)
                    elements = Arrays.copyOf(elements, size * 2 + 1);
            }
        }
    }

    혹은

    public class Stack<E> {
        private Object[] elements;
        private int size;
        public static final int DEFAULT_INITIAL_CAPACITY = 16;

        //배열 elements 은 push(E) 로 넘어온 E 인스턴스만 담는다.
        //따라서 타입 안전성을 보장하지만,
        //이 배열의 런타임 타입은 E[] 가 아닌 Object[] 다!
        @SuppressWarnings("unchecked")
        public Stack() {
            //elements 은 private 이며 클라이언트에 전달되지 않으므로 비검사 형변환은 확실히 안전한다.
            //SuppressWarnings 으로 비검사 예외를 제거하라.
            this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(E el) {
            ensureCapacity();
            elements[size++] = el;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            //push 에서 E 타입만 허용하므로 이 형변환은 안전하다.
            @SuppressWarnings("unchecked")
            E r = (E) elements[--size];
            elements[size] = null; // 다 쓴 참조 해제.
            return r;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, size * 2 + 1);
        }
    }

    제네릭의 이로움.
    Stack<String> stack = new Stack<>();
    for (String arg: args)
        stack.push(arg);
    while (!stack.isEmpty())
        System.out.println(stack.pop().toLowerCase()); // 제네릭을 사용하므로 클라이언트는 형변환 없이 사용 가능.

    한정적 타입 매개변수(bounded type parameter)
    타입 매개변수 목록인 <E extends Delayed> 은 java.util.concurrent.Delayed 의 하위 타입만 받는다는 뜻이다.
    클라이언트는 곧바로 타입 매개변수 타입의 인스턴스를 꺼내 Delayed 클래스의 메서드를 호출할 수 있다.

    핵심 정리.
    클라이언트에서 직접 형번환해야 하는 타입보다 제네릭 타입이 더 안정하고 쓰기 편하다.
    그러니 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 기존 타입 중 제네릭이었어야 하는 게 있다면
    제네릭 타입으로 변경하면, 기존 클라이언트에는 아무 영향을 주지 않아면서, 사용자에게 편리함을 제공한다.

이왕이면 제네릭 메서드로 만들라.
    클래스와 마찬가지로, 메서드도 제네릭으로 만들 수 있다.
    매개변수화 타입을 받는 정적 유틸리티 메서드는 보통 제네릭이다.

    private static <T> int indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {
        int low = 0;
        int high = list.size()-1;

        while (low <= high) {
            int mid = (low + high) >>> 1;
            Comparable<? super T> midVal = list.get(mid);
            int cmp = midVal.compareTo(key);

            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found
    }

    //로 타입을 사용하지 마라. 타입에 안전하지 않다. (ClassCastException 발생 가능)
    public static Set union(Set s1, Set s2) {
        Set result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    제네릭 메서드 생성 방법.
    메서드 선언에서의 사용하는 원소 타입을 타입 매개변수로 명시하고, 메서드 안에서 이 타입 매개변수만 사용하게 수정하면 된다.
    (메서드 제한자와 반환 타입 사이에 타입 매개변수를 선언)

    //제네릭 메서드. 로 타입과 달리 타입 안전하다!
    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    한정적 와일드 카드 (ex List<E extends Number>) 을 사용하면 더 유연하게 개선할 수 있다.

    싱글턴 팩토리.
        불변 객체(싱글톤) 를 여러 타입으로 활용할 수 있게 한다.
        //보충

    재귀적 타입 한정(recursive type bound)
    자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정.
    재귀적 타입 한정은 주로 타입의 자연적 순서를 정한는 Comparable 인터페이스와 함께 쓰인다.

    public static <E extends Comparable<E>> E max(Collection<E> c);

    타입 한정인 <E extends Comparable<E>> 는 모든 타입 E는 자신과 비교할 수 있다.
    //Comparable 의 타입 인자가 같은 타입. 즉 E 는 Comparable 에서도 타입 매개변수로 정해진 타입이여야 한다. (재귀적 타입 한정)
    public static <E extends Comparable<E>> E max(Collection<E> c) {
        checkArgument(!c.isEmpty());
        E result = null;
        for (E e: c)
            if (result == null || e.compareTo(result) > 0)
                result = e;
        return result;
    }

    핵심 정리.
    제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기 쉽다.
    타입과 마찬가지로, 메서드도 형변환 없이 사용할 수 있는 편이 좋으며 (컴파일러의 도움을 받아), 많은 경우 제네릭 메서드가 되어야 한다.
    타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭을 만들자.

한정적 와일드카드를 사용해 API 유연성을 높이라.
    매개변수화 타입은 불공변(invariant) 다. 배열은 공병(variant) 이다.
    서로 다른 타입 Type1 과 Type2가 있을 때 List<Type1> 은 List<Type2>의 하위 타입도 상위 타입도 아니다.
    List<Object> 은 List<String> 의 상위 타입이 아니다.
    List<Object> 은 어떤 객체든 넣을 수 있지만 List<String> 에는 문자열만 넣을 수 있다. (확장 방식이 아닌 좁혀진 방식이다. - 리스코프 치환 원칙 위배)

    static class Stack<E> {
        private Object[] elements;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;
        private int size;

        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(E e) {
            ensureCapacity();
            elements[size++] = e;
        }

        private void ensureCapacity() {
            if (size == elements.length)
                elements = Arrays.copyOf(elements, 2 * size + 1);
        }

        public E pop() {
            if (size == 0)
                throw new EmptyStackException();
            @SuppressWarnings("unchecked")
            E el = (E) elements[--size];
            elements[size] = null; //다 쓴 참조 해제.
            return el;
        }

        public void pushAll(Iterable<E> src) {
            for (E e: src)
                push(e);
        }

        public void popAll(Collection<E> dst) {
            while (!isEmpty())
                dst.add(pop());
        }
    }

    Stack<Number> stack = new Stack<>();
    List<Integer> intVals = ImmutableList.of(1, 2, 3);
    stack.pushAll(intVals); //개념적 하위 호환 Iterable<Integer> 을 인자로 전달!
                            //즉, Iterable<Number> 와 Iterable<Integer> 은 호환되지 않는다.

    이러한 상황에서는 한정적 와일드 타입(Bounded wildcard type) 을 사용해야 한다.
    pushAll 의 입력 매개변수 타입은 'E 의 Iterable' 이 아니라 'E 의 하위 타입의 Iterable' 이어야 하며,
    와일드 카드 타입 Iterable<? extends E> 이어야 한다. (extends 했지만 자기 자신도 포함한다.)

    public void pushAll(Iterable<? extends E> src) {
        for (E e: src)
            push(e);
    }

    이번에는 popAll 의 매개변수의 타입이 'E 의 Collection' 이 아니라 'E의 상위 타입의 Collection' 이어야 한다.

    public void popAll(Collection<? super E> dst) {
        while (!isEmpty())
            dst.add(pop());
    }

    유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 "와일드카드 타입"을 사용하라.

    다음 공식을 외워두면 어떤 와일드카드 타입을 써야 하는지 기억하는 데 도움이 된다.
    producer-extends, consumer-super
    즉, 매개변수화 타입 T가 생상자라면 <? extends T> 를 사용하고, 소비자라면 <? super T> 을 사용하라.
    Stack 예에서 pushAll 의 src 매개변수는 Stack 이 사용할 E 인스턴스를 생산하므로 Iterable<? extends E> 이다.
    Stack 예에서 popAll 의 dst 매개변수는 Stack 으로부터 E 인스턴스를 소비하므로 Collection<? super E> 이다.

    다음의 다른 예이다.
    public Chooser(Collection<T> choices)
    choices 로 부터 T 를 생산하므로
    public Chooser(Collection<? extends T> choices) 이다.

    Union 을 한정적 와일드카드 타입을 사용하여 바꿔보자.

    public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

    public static void main(String[] args) {
        final ImmutableSet<Integer> integers = ImmutableSet.of(1, 3, 5);
        final ImmutableSet<Double> doubles = ImmutableSet.of(2.0, 4.0, 6.0);
        Set<Number> numbers = union(integers, doubles); //E가 호환되지 않는다. (타입 매개변수는 불공변임을 기억하자.)
    }

    public static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {
        Set<E> result = new HashSet<>(s1);
        result.addAll(s2);
        return result;
    }

제네릭과 가변인수를 함께 쓸 때는 신중하라.
    가변인수(varargs)는 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는데,
    허점이 있다.
    가변 인수 메서드를 호출하면 가변인수를 담기 위핸 배열이 자동으로 만들어진다.
    제네릭의 매개변수로 선언된 가변 인수 메서드를 호출할 때 varargs 매개변수를 담는 "제네릭 배열"이 만들어진다.

        - 실체화 불가 타입(타입 매개변수, 제네릭 타입, 매개변수화 타입)은 런타임에 타입 관련 정보가 지워진다.
        - 매개변수화 타입과 모든 제네릭 타입은 실체화 되지 않으므로 "제네릭 배열"이 아닌 Object 배열이 varargs 으로 생성된다.

    메서드를 선언할 때 실체화 불가 타입으로 varargs 매개 변수를 선언하면 컴파일러는 경고를 보낸다.
        -매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 프로세스의 Heap 오염이 발생한다.

    static void dangerous(List<String>... stringLists) {
        List<Integer> intList = ImmutableList.of(42);
        Object[] objects = stringLists;
        objects[0] = intList;       //Heap 오염 발생
        String s = stringLists[0].get(0);   //ClassCastException
    }
    //제네릭 varargs 배열 매개변수에 값을 저장하는 것은 안전하지 않다.

    자바 7에서는 @SafeVarargs 어노테이션이 추가되어 제네릭 가변인수 메서드 작성자가 클라이언트 측에 발생하는 경고를 숨길 수 있게 되었다.
    @SafeVarargs 어노테이션
        :메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치다.

    제네릭 매개변수를 가지는 varargs 메서드가 안전하다는 것은?
        :메서드가 "전달된 배열"에 이무것도 저장하지 않고, 그 배열의 참조가 "밖으로 노출되지" 않는다면 타입 안전하다.
        :달리 말하면, 이 varargs 매개변수 배열이 호출자로부터 그 메서드로 순수하게 인수를 전달하는 일만 한다면 메서드는 안전하다.

    public static void main(String[] args) {
        String[] attributes = pickTwo("좋은", "빠른", "저렴한"); //ClassCastException
        //pickTwo 는 String[] 배열을 리턴한다.
        //toArray 은 런타임시 타입 정보가 지워지므로 Object[] 을 리턴한다.
    }

    static <T> T[] toArray(T... args) {
        T[] array = args;
        System.out.println(array.getClass()); //Object[]
        return args;
    }

    static <T> T[] pickTwo(T a, T b, T c) {
        switch (ThreadLocalRandom.current().nextInt(3)) {
            case 0: return toArray(a, b); //리턴시 Object[] 을 컴파일로는 자동으로 캐스팅한다 (제네릭 지원).
            case 1: return toArray(a, c);
            case 2: return toArray(b, c);
        }
        throw new AssertionError();
    }

    "제네릭 varargs 매개변수 배열"에 다른 메서드가 접근하도록 허용하면 안전하지 않다.
        :달리 말해 제네릭 varargs 매개변수를 선언한 배열은 그 참조를 외부로 참조시키지 마라.
    혹은 다음 메서드도 안전하다.

    @SafeVarargs
    static <T> List<T> flatten(List<? extends T>... lists) {
        List<T> result = new ArrayList<>();
        for (List<? extends T> list: lists)
            result.addAll(list);
        return result;
    }

    @SafeVarargs 어노테이션을 사용할 때의 규칙.
        :제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarargs 를 달라. (그래야 컴파일러 경고를 없앨 수 있다.)
        둘 중 하나라면 수정하라!
            :varargs 매개변수 배열에 아무것도 저장하지 않는다.
            :그 배열을 신뢰할 수 없는 코드에 노출시키지 않는다.
        :@SafeVarargs 은 재정의할 수 없는 메서드에만 달아야 한다.

    위을 따를 수 없다면 varargs 을 사용하지 말고 아래처럼 사용하라. (에러를 피할 수 있다.)
    static <T> List<T> flatten(List<List<? extends T>> lists) {
        List<T> result = new ArrayList<>();
        for (List<? extends T> list: lists)
            result.addAll(list);
        return result;
    }

    핵심 정리.
    가변인수와 제네릭은 궁합이 좋지 않다.
    가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열(공변 - variant)과 제네릭의 타입 규칙(불공변 - invariant)이 서로 다르기 때문이다.
    메서드에 제네릭 varargs 매개변수를 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs 어노테이션을 달자.

타입 안전 이종 컨테이너를 고려하라.
    Set<T>, Map<K,V> 가 아닌 ThreadLocal<T>, AtomicReference<T> 등
    타입 매개변수화되는 대상이 (원소가 아닌) 컨테이너 자신인 컨테이너를 "단일원소 컨테이너"라 한다.

    모든 하나의 컨테이너에서 매개변수화할 수 있는 타입의 수가 제한된다.

   컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하면
   더 유연하게 제네릭 컨테이너를 설계할 수 있다. (데이터베이스의 행은 임의 개수의 열이 가지는데, 열을 타입 안전하게 사용하고 싶을때)


    Class<T>.
        :class 의 리터럴 타입은 Class 가 아닌 Class<T> 이다.
        :즉 String.class 의 타입은 Class<String> 이고 Integer.class 의 타입은 Class<Integer> 이다.
        public final class Class<T> implements ...

        :컴파일타임 타입 정보와 런타임 타입 정보를 알아내기 위해 메서드들이 주고받는 class 리터럴을 타입 토큰(type token) 이라 한다.


열거 타입과 어노테이션.
    :자바의 "특수한 목적의 참조 타입"

int 상수 대신 열거 타입을 사용하라.
    정수 열거 패턴(int enum pattern) 기법에는 단점이 많다.
        :타입 안전을 보장할 수 없으며 표현력이 좋지 않다.
        :접두어를 사용하여 다른 타입임을 암시하여 이름 충돌을 방지하지만 안전하지 않다.
        :정수 상수를 문자열로 치환하기 까다로우며 숫자 자체를 디버깅하면 도움이 되지 않는다.
        :문자열 상수또한 마찬가지로 상수의 이름 대신 문자열 값을 그대로 하드코딩하기에 오타등으로 런타임 버그가 생길 수 있다.

    public static final int APPLE_FUJI = 0;
    public static final int APPLE_PIPPIN = 1;

    public static final int ORANGE_NAVEL = 0;
    public static final int ORANGE_TEMPLE = 1;

    자바 열거 타입.
        :열거 타입은 사실 완전한 형태의 클래스이다.
        :상수 하나당 자신의 인스턴스를 만들어 public static final 필드로 공유한다 (싱글톤).
            - 반대로 원소가 하나뿐인 열거 타입은 싱글턴이다.
        :열거 타입은 타입 안전성을 제공한다.
            - Apple 열거 타입을 매개변수로 받는 메서드를 선언했다면, 건네받는 참조는 null 혹은 열거의 원소 둘 중 하나이다.
        :열거 타입의 toString 은 상수가 아닌 적합한 문자열로 자동으로 변환한다.
        :Enum.values() 은 선언된 순서로 저장된 배열을 리턴한다.
    public enum Apple {
        FUJI, PIPPIN, GRANNY_SMITH
    }
    public enum Orange {
        NAVEL, TEMPLE, BLOOD
    }

    열거 타입의 추가 기능.
        :열거 타입에는 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이를 구현하게 할 수 있다.
            - 실제로는 클래스이므로 위의 추가 기능이 가능하다.
            - 실제로 enum 은 이미 Comparable 과 Serializable 을 이미 구현해놓았다.

        :열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
            - 열거 타입은 근본적으로 불변이라 모든 필드는 final 이ㅓㅇ야 한다.
            - 필드를 public 으로 선언해도 되지만, private 으로 두고 별도의 public 접근자 메서드를 두는 편이 낫다(아이템 16)
                아이템 16: public 클래스는 절대 가변 필드를 직접 노출해서는 안되며, 불변 필드라도 노출하면 덜 위험하지만 안심할 수 없다.
                반대로 package-private 클래스나 private 중첩 클래스는 종종 노출하는 편이 나을 때도 있다.
      enum Planet {
          MERCURY(3.302e+23, 2.439e6),
          VENUS(4.869e+24, 6.052e6),
          EARTH(5.975e+24, 6.3789e6),
          MARS(6.419e+23, 3.393e6),
          JUPITER(1.899e+27, 7.149e7),
          SATURN(5.685e+26, 6.027e7),
          URANUS(8.683e+25, 2.556e7),
          NEPTUNE(1.024e+26, 2.439e7);

          private final double mass;              //질량(단위: kg)
          private final double radius;            //반지름(단위: m)
          private final double surfaceGravity;    //표면중력(단위: m / s^2)

          // 중력상수(단위: m^3 / kg s^2)
          public static final double G = 6.67300E-11;

          Planet(double mass, double radius) {
              this.mass = mass;
              this.radius = radius;
              surfaceGravity = G * mass / (radius * radius);
          }

          public double mass() {
              return mass;
          }

          public double radius() {
              return radius;
          }

          public double surfaceGravity() {
              return surfaceGravity;
          }

          public double surfaceWeight(double mass) {
              return mass * surfaceGravity;
          }
      }

      :열거 타입을 하나 제거하더라도 제거한 상수를 참조하지 않는 클라이언트에는 아무 영향이 없다.
      class WeightTable {
          public static void main(String[] args) {
              args = new String[]{"1.91"};
              double earthWeight = Double.parseDouble(args[0]);
              double mass = earthWeight * Planet.EARTH.surfaceGravity();
              for (Planet p: Planet.values())
                  System.out.printf("%s 에서의 무게는 %f 이다.\n", p, p.surfaceWeight(mass));
          }
      }


    일반 클래스와 마찬가지로, 그 기능을 클라이언트에 노출해야 할 합당한 이유가 없다면 private 혹은 package-private 으로 만들어라. (아이템 15)
        아이템 15: 프로그램 요소의 접근성을 가능한 최소한으로 하라. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 하라.
        - 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만들어라.

        - ex) RoundingMode 은 private, package-private 이 될 수 있었지만 라운딩은 BigDecimal 과 관련 없는 영역에서 유용한 개념이라 톱레벨로 올렸다.
    public enum RoundingMode {

        UP(BigDecimal.ROUND_UP),

        DOWN(BigDecimal.ROUND_DOWN),

        CEILING(BigDecimal.ROUND_CEILING),

        FLOOR(BigDecimal.ROUND_FLOOR),

        HALF_UP(BigDecimal.ROUND_HALF_UP),

        HALF_DOWN(BigDecimal.ROUND_HALF_DOWN),

        HALF_EVEN(BigDecimal.ROUND_HALF_EVEN),

        UNNECESSARY(BigDecimal.ROUND_UNNECESSARY);
        final int oldMode;

        private RoundingMode(int oldMode) {
            this.oldMode = oldMode;
        }

        public static RoundingMode valueOf(int rm) {
            switch(rm) {

            case BigDecimal.ROUND_UP:
                return UP;

            case BigDecimal.ROUND_DOWN:
                return DOWN;

            case BigDecimal.ROUND_CEILING:
                return CEILING;

            case BigDecimal.ROUND_FLOOR:
                return FLOOR;

            case BigDecimal.ROUND_HALF_UP:
                return HALF_UP;

            case BigDecimal.ROUND_HALF_DOWN:
                return HALF_DOWN;

            case BigDecimal.ROUND_HALF_EVEN:
                return HALF_EVEN;

            case BigDecimal.ROUND_UNNECESSARY:
                return UNNECESSARY;

            default:
                throw new IllegalArgumentException("argument out of range");
            }
        }

        BigDecimal decimal = BigDecimal.valueOf(30.355);
        BigDecimal value = decimal.divide(BigDecimal.valueOf(3.), 3, RoundingMode.DOWN);
        System.out.println(value);

        decimal = new BigDecimal(30.355);
        value = decimal.divide(BigDecimal.valueOf(3.), 3, RoundingMode.UP);
        System.out.println(value);

        /**
         * Returns a {@code BigDecimal} whose value is {@code (this /
         * divisor)}, and whose scale is as specified.  If rounding must
         * be performed to generate a result with the specified scale, the
         * specified rounding mode is applied.
         *
         * @param  divisor value by which this {@code BigDecimal} is to be divided.
         * @param  scale scale of the {@code BigDecimal} quotient to be returned.
         * @param  roundingMode rounding mode to apply.
         * @return {@code this / divisor}
         * @throws ArithmeticException if {@code divisor} is zero,
         *         {@code roundingMode==RoundingMode.UNNECESSARY} and
         *         the specified scale is insufficient to represent the result
         *         of the division exactly.
         * @since 1.5
         */
        public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
            return divide(divisor, scale, roundingMode.oldMode);
        }

    열거 타입과 열거 타입에 따른 다른 동작 구현하기.
        :열거 타입에 메서드를 추가하고 switch 문을 통해 열거 타입마다 다른 동작을 추가한다.
            - 열거가 추가할때마다 코드가 변경해야 되며 마지막 분기에 런타임 오류가 날 수 있다. (switch 문을 피하라)
        :열거 타입에 추상 메서드를 선언할 수 있고 각 열거마다 다른 동작을 하도록 구현할 수 있다. (다형성 - template 패턴)
            - 열거 타입에 추상 메서드를 선언하고 각 상수별 클래스 몸체에 상수 자신에 맞게 재정의한다. (constant-specific method implementation)
            - switch 문과는 다르게 추상 메서드로 구현을 강제하였으므로 열거가 추가될 때 로직이 구현되지 않았다면 컴파일시 에러가 발생한다.

    enum Operation {
        PLUS, MINUS, TIMES, DIVIDE;

        public double apply(double x, double y) {
            switch (this) {
                case PLUS: return x + y;
                case MINUS: return x - y;
                case TIMES: return x * y;
                case DIVIDE: return x / y;
            }
            throw new AssertionError("Unknown operation: " + this);
        }
    }

    //상수별 메서드 구현
    enum Operation {
        PLUS { public double apply(double x, double y) { return x + y; } },
        MINUS { public double apply(double x, double y) { return x - y; } },
        TIMES { public double apply(double x, double y) { return x * y; } },
        DIVIDE { public double apply(double x, double y) { return x / y; } };

        public abstract double apply(double x, double y);
    }

   //상수별 몸체 메서드 구현과 데이터를 사용한 열거

   enum Operation {
       PLUS("+") { public double apply(double x, double y) { return x + y; } },
       MINUS("-") { public double apply(double x, double y) { return x - y; } },
       TIMES("*") { public double apply(double x, double y) { return x * y; } },
       DIVIDE("/") { public double apply(double x, double y) { return x / y; } };

       private final String symbol;

       Operation(String symbol) {
           this.symbol = symbol;
       }

       @Override
       public String toString() {
           return symbol;
       }

       public abstract double apply(double x, double y);
   }


   args = new String[]{"2.0", "3.0"};
   double x = Double.parseDouble(args[0]);
   double y = Double.parseDouble(args[1]);
   for (Operation op: Operation.values())
       System.out.printf("%f %s %f = %+f\n", x, op, y, op.apply(x, y));

   열거 타입과 문자열.
        :열거 타입에는 문자열 입력받아 열거 상수를 반환해주는 valueOf 메서드가 자동 생성된다.
        toString 을 재정의하는 경우, 또 다른 포맷의 문자열을 열거 상수로 반환해주는 fromString 메서드도 함께 제공하는 것을 고려하자.

   enum Operation {
       PLUS("+") { public double apply(double x, double y) { return x + y; } },
       MINUS("-") { public double apply(double x, double y) { return x - y; } },
       TIMES("*") { public double apply(double x, double y) { return x * y; } },
       DIVIDE("/") { public double apply(double x, double y) { return x / y; } };

       private static final Map<String, Operation> stringToEnum = Stream.of(values()).collect(toMap(Object::toString, e -> e));

       private final String symbol;

       Operation(String symbol) {
           this.symbol = symbol;
       }

       public String toString() {
           return symbol;
       }

   열거 타입 상수끼리의 코드 교환. (Enum 의 전략 패턴 도입)
        :열거 타입 상수끼리 코드(메서드)를 공유하기 어렵다.
        :이럴땐 전략 패턴을 도입하여 하나의 메서드가 열거 상수에 다른 "전략"을 선택하도록 위임한다.

   //switch 문으로 상수에 따라 다른 분기를 가진다 (switch 은 위험하다)
   //WEEKDAY 이냐, 평일이냐 에따라 코드가 달라진다는 것을 파악하라.
   //이렇게 되면 특정 날에 따라 다른 "전략"을 사용한다는 것이 파악된다.
    enum PayrollDay {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;

        private static final int MINS_PER_SHIFT = 8 * 60;

        int pay(int minutesWorked, int payRate) {
            int basePay = minutesWorked * payRate;
            int overtimePay;
            switch (this) {
                case SATURDAY: case SUNDAY:
                    overtimePay = basePay / 2;
                    break;
                default:
                    overtimePay = minutesWorked <= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
            }
            return basePay + overtimePay;
        }
    }

    enum PayrollDay {
        MONDAY(WEEKDAY), TUESDAY(WEEKDAY), WEDNESDAY(WEEKDAY), THURSDAY(WEEKDAY), FRIDAY(WEEKDAY),
        SATURDAY(WEEKEND), SUNDAY(WEEKEND);

        private final PayType payType;

        PayrollDay(PayType payType) {
            this.payType = payType;
        }

        int pay(int minutesWorked, int payRate) {
            return payType.pay(minutesWorked, payRate);
        }

        enum PayType {
            WEEKDAY {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked <= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2;
                }
            },
            WEEKEND {
                int overtimePay(int minsWorked, int payRate) {
                    return minsWorked * payRate / 2;
                }
            };

            public static final int MINS_PER_SHIFT = 8 * 60;

            abstract int overtimePay(int mins, int payRate);

            int pay(int minsWorked, int payRate) {
                int basePay = minsWorked * payRate;
                return basePay + overtimePay(minsWorked, payRate);
            }
        }
    }

    핵심 정리.
        열거 타입은 정수 상수보다 뛰어나다.
        더 읽기 쉽고 안전하고 강력하다.
        열거 타입은 각 원소가 특정 데이터와 연결 짓거나 상수마다 다른 동작이 필요하다면 생성자와 메서드를 사용할 수 있다.
        드물게는 하나의 메서드가 상수별로 다르게 동작할 때는 추상 메서드를 사용하여 몸체에 다른 동작을 구현하고,
        열거 타입 상수 일부가 같은 동작을 공유한다면 switch 문 대신 "전략 패턴" 을 도입하여 전략 열거 타입 패턴을 사용하자.

ordinal 메서드 대신 인스턴스 필드를 사용하라.
    열거 타입 상수는 자연스럽게 하나의 정수값에 대응되고, 모든 이넘(열거 타입 상수)은 그 열거 타입에서 몇 번째 위치인지를 반환하는
    ordinal 이라는 메서드를 제공한다.

    하지만 ordinal 은 사용하지 말자.
        : 이미 사용 중인 정수와 값이 같은 상수는 추가할 방법이 없다.
        : 이넘의 순서는 바뀔 수 있다.
        : 값 중간을 비워둘 수 없다.

    enum Ensemble {
        SOLO, DUET, TRIO, QUARTET, QUINTET, SEXTET, SEPTET, OCTET, NONET, DECTET;

        public int numberOfMusicians() { return ordinal() + 1; };
    }

    이넘에 연결된 데이터는 항상 "인스턴스 필드"에 저장하자.

비트 필드 대신 EnumSet 을 사용하라.

    쉬프트 연산자로 2의 제곱하기.
        왼쪽은 1로 두고 오른쪽 부분에 2을 제곱할 지수 부분을 둔다.
         1 << 0 = 2^0, 1 << 1 = 2^1, 1 << 3 = 2^2, , 1 << 4 = 2^3
     비트별 OR 연산.
        비트별 OR 연산을 사용하면 여러 상수를 하나의 집합으로 모을 수 있다.

    public class Text {
        public static final int STYLE_BOLD = 1 << 0;            //1
        public static final int STYLE_ITALIC = 1 << 1;          //2
        public static final int STYLE_UNDERLINE = 1 << 2;       //4
        public static final int STYLE_STRIKETHROUGH = 1 << 3;   //8
    }

    Integer.toBinaryString(STYLE_BOLD | STYLE_ITALIC);  //11
    Integer.toBinaryString(STYLE_UNDERLINE | STYLE_BOLD);   //101
    Integer.toBinaryString(STYLE_STRIKETHROUGH | STYLE_ITALIC); //1010

    집합을 (Set) 위한 비트 필드를 사용하지 마라.
        :비트 필드 값은 해석하기 어렵다.
        :비트 필드 하나에 녹아 있는 모든 원소를 순회하기 어렵다.

    집합(Set)을 위해 비트필드 대신 EnumSet 을 사용하라.
        EnumSet 은 열거 타입 상수의 값으로 구성된 집합을 표현한다.
        상수를 EnumSet 은 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여준다.

    EnumSet 은 부분 집합 생성을 위한 정적 팩토리를 제공한다.

    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2) {
        EnumSet<E> result = noneOf(e1.getDeclaringClass());
        result.add(e1);
        result.add(e2);
        return result;
    }

    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
            Enum<?>[] universe = getUniverse(elementType);
            if (universe == null)
                throw new ClassCastException(elementType + " not an enum");

            if (universe.length <= 64)
                return new RegularEnumSet<>(elementType, universe);
            else
                return new JumboEnumSet<>(elementType, universe);
        }
    }

    핵심 정리.
    열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다 해도 비트 필드를 사용할 이유는 없다.
    EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공한다.

ordinal 인덱싱 대신 EnumMap 을 사용하라.
    배열이나 리트스트에서 원소를 꺼낼 때 ordinal 메서드로 인덱를 얻는 코드가 있다.
        :Set 으로 된 배열에 인덱스를 키로, Set 의 원소를 객체로 사용하면 index 을 사용하는 Map 이 구현된다.

        Set<Plant>[] plantsByLifeCycle = (Set<Plant>[]) new Set[Planet.values().length];
        for (int i = 0; i < plantsByLifeCycle.length; i++)
            plantsByLifeCycle[i] = new HashSet<>();
        for (Plant p: garden )
            plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);
        for (int i = 0; i < plantsByLifeCycle.length; i++)
            System.out.printf("%s: %s%n", Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);

    열거 타입을 키로 사용하는 EnumMap
        :열거 타입을 키로 사용할시엔 아주 빠른 EnumMap 사용을 고려하자.
        :EnumMap 은 더 짧고 명료하고 안전하고 성능도 빠른다.
        :위의 코드는 배열 인덱스를 계산하는 과정에서 오류가 날 가능성이 있지만 아래 코드는 그 가능성을 원천 봉쇄한다.

        EnumMap<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle = new EnumMap<>(Plant.LifeCycle.class);
        for (Plant.LifeCycle lc: Plant.LifeCycle.values())
            plantsByLifeCycle.put(lc, new HashSet<>());
        for (Plant p: garden)
            plantsByLifeCycle.get(p.lifeCycle).add(p);
        System.out.println(plantsByLifeCycle);

    스트림을 이용한 EnumMap 생성.
        garden.stream().collect(groupingBy(p -> p.lifeCycle));
            :고유한 Map 을 생성한다. groupingBy 에 키를 map 했다.
        garden.stream().collect(
            groupingBy(p -> p.lifeCycle, () -> new EnumMap<>(Plant.LifeCycle.class), toSet()));
            :groupingBy 메서드에 mapFactory 을 두번째 인자로 전달하여 맵 구현체를 명시해 호출할 수 있다.

    한 상태에서 다른 상태로 전이하는 EnumMap 구현. (BiMap: Enum 원소 끼리 연결된 Map)
        :Collector 은 여러 차례 중복으로 사용할 수 있다.
        groupingBy 로 외부 컨테이너을 정의하며, groupingBy 의 마지막 인자로 중첩 groupingBy 을 정의한다.
        Stream.of(Transition.values()).collect(
                    groupingBy(t -> t.from, () -> new EnumMap<>(Phase.class),
                        toMap(t -> t.to, t -> t, (x, y) -> y, () -> new EnumMap<>(Phase.class))))

    핵심 정리.
        배열의 인덱스를 얻기 위해 이넘의 ordinal 을 쓰는 것은 좋지 않으니, 대신 EnumMap 을 사용하라.
        다차원 관계는 EnumMap<..., EnumMap<...>> 으로 표현하라.

확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.
    :대부분 상황에서 열거 타입을 확장하는 것은 좋지 않은 상태이다.
    :연산 코드(operation code) 의 열거는 확장하기 좋다.
    :이따금 API 가 제공하는 기본 연산외에 사용자가 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있다.

    열거용 인터페이스를 정의하고 열거 타입이 이 인터페이스를 구현하게 한다.

명명 패턴보단 어노테이션을 사용하라.
    :전통적으로 도구나 프레임워크가 특별히 다뤄야 할 프로그램 요소에는 구분되는 명명 패턴을 사용했다.
        - Junit 버전 3까지 테스트 메서드 이름을 test 로 시작하게끔 해야했다.

    명명 패턴의 단점.
        :오타에 의한 에러.
        :올바른 프로그램 요소에서만 사용되리라는 보증할 수 없다.
            -> Junit 버전 3에서 메서드가 아닌 클래스에 명명 패턴을 적용하면, Junit 은 테스트 요소로 보지도 않지만 더 나쁜점은 경고 메시지 보내지 않는다.
        :매개변수를 전달할 방법이 없다.

    명명 패턴보단 어노테이션을 사용하라.
        :어노테이션은 적용된 클래스의 의미에 직접적인 영향을 주지 않는다.
        :대상 코드의 의미는 그대로 둔 채 그 어노테이션에 관심 있는 도구에 특별한 처리를 할 기회를 준다.

        /**
         * 테스트 메서드임을 선언하는 어노테이션이다.
         * 매개변수 없는 정적 메서드 전용이다.
         */
        @Retention(RetentionPolicy.RUNTIME) //RETENTION 은 어노테이션 정보의 유지 기간을 의미한다.
        @Target(ElementType.METHOD)         // 해당 어노테이션의 적용 대상을 지정한다.
        public @interface Test {
        }

        메타어노테이션(meta-annotation)
            : 어노테이션의 세부 데이터. @Retention, @Target 등이 있다.

        @Retention(RetentionPolicy.RUNTIME)
            : 해당 어노테이션이 런타임에도 유지되어야 한다는 표시.
        @Target(ElementType.METHOD)
            : 해당 어노테이션이 메서드 선언에서만 사용됨을 지정.

    class Sample {

        @Test public static void m1() { } //성공해야 한다.

        public static void m2() { }

        @Test public static void m3() { throw new RuntimeException("실패"); } //실패해야 한다.

        public static void m4() { }

        @Test public void m5() { } //잘못 사용한 예: 정적 메서드가 아니다.

        public static void m6() { }

        @Test public static void m7() { throw new RuntimeException("실패"); } //실패해야 한다.

        public static void m8() { }

    }

    public static void main(String[] args) throws ClassNotFoundException {
            int tests = 0;
            int passed = 0;
            Class<?> testClass = Class.forName("com.siwoo.ef.anno.Sample");
            for (Method m: testClass.getDeclaredMethods()) {
                if (m.isAnnotationPresent(Test.class)) {
                    tests++;
                    try {
                        m.invoke(null);
                        passed++;
                    } catch (InvocationTargetException wrappedEx) {
                        Throwable exc = wrappedEx.getCause();
                        System.out.println(m + " 실패: " + exc);
                    } catch (Exception e) {
                        System.out.println("잘못 사용한 @Test: " + m);
                    }
                }
            }
            System.out.printf("성공: %d, 실패: %d%n", passed, tests - passed);
        }
    }

    AnnotatedElement.isAnnotationPresent
        :AnnotatedElement 인터페이스는 Class, Method 클래스가 확장 구현.
        :해당 Element 에서 인자로 주어진 어노테이션이 적용됬는지 알려준다.

    InvocationTargetException
        :리플렉션을 이용해 메서드를 호출할때 타겟 메서드에서 발생한 예외의 Wrapper 예외 클래스.
        :InvocationTargetException 의 getCause() 은 실제 타겟의 예외를 리턴한다.

    /**
         * Returns true if an annotation for the specified type
         * is <em>present</em> on this element, else false.  This method
         * is designed primarily for convenient access to marker annotations.
         *
         * <p>The truth value returned by this method is equivalent to:
         * {@code getAnnotation(annotationClass) != null}
         *
         * <p>The body of the default method is specified to be the code
         * above.
         *
         * @param annotationClass the Class object corresponding to the
         *        annotation type
         * @return true if an annotation for the specified annotation
         *     type is present on this element, else false
         * @throws NullPointerException if the given annotation class is null
         * @since 1.5
         */
        default boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {
            return getAnnotation(annotationClass) != null;
        }

    어노테이션의 인자
        :어노테이션의 인자(parameter) 을 선언하면 해당 어너테이션을 사용할 때마다 다른 매개변수(argument) 을 전달할 수 있다.

    Executable.getAnnotation
        :해당 엘리먼트에 선언된 어노테이션을 리턴한다.

    /**
     * 명시한 예외를 던져야만 성공하는 테스트 메서드용 어노테이션
     */
    @Retention(RetentionPolicy.RUNTIME)
    @Target(ElementType.METHOD)
    @interface ExceptionTest {
        Class<? extends Throwable> value(); //제네릭의 타입 안전 이종 컨테이너.
    }

    한정적 타입 토큰
        :AnnotatedElement 인터페이스는 한정적 타입 토큰을 적극적으로 사용.
        public <T extends Annotation> T getAnnotation(Class<T> annotationType)
        여기서 annotationType 인수는 한정적 타입 토큰으로 어노테이션된 요소는 그 키가 어노테이션 타입인, 타입 안전 이종 컨테이너이다.
    타입 안전 이종 컨테이너.
        :주로 Class을 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 한다.

    for (Method m: testClass.getDeclaredMethods()) {
            if (m.isAnnotationPresent(ExceptionTest.class)) {
                try {
                    tests++;
                    m.invoke(null);
                    //실패
                } catch (InvocationTargetException e) {
                    Throwable cause = e.getCause();
                    Class<? extends Throwable> expExc = m.getAnnotation(ExceptionTest.class).value();
                    if (expExc.isInstance(cause))
                        passes++;
                } catch (Exception e) {
                    //Ignore
                }
            }
        }

    AnnotatedElement.getAnnotation
        :해당 엘리먼트에 적용된 해당 어노테이션(메타 정보)를 리턴하며, 어노테이션 인스턴스는 매개변수의 정보를 가진다.

      /**
         * Returns this element's annotation for the specified type if
         * such an annotation is <em>present</em>, else null.
         *
         * @param <T> the type of the annotation to query for and return if present
         * @param annotationClass the Class object corresponding to the
         *        annotation type
         * @return this element's annotation for the specified annotation type if
         *     present on this element, else null
         * @throws NullPointerException if the given annotation class is null
         * @since 1.5
         */
        <T extends Annotation> T getAnnotation(Class<T> annotationClass);

    어노테이션의 배열 매개변수.
       어노테이션 인스턴스에 매개변수를 전달할때, {} 문법을 사용한다.


    @ExceptionTest({IndexOutOfBoundsException.class, NullPointerException.class})
    public static void doublyBad() {
        List<String> list = new ArrayList<>();
        list.addAll(5, null);
    }

    int tests = 0;
    int passed = 0;
    Class<?> testClass = Class.forName("com.siwoo.ef.anno.Sample2");
    for (Method m: testClass.getDeclaredMethods()) {
        if (m.isAnnotationPresent(ExceptionTest.class)) {
            tests++;
            try {
                m.invoke(null);
                //실패
            } catch (Throwable wrappedExc) {
                Throwable exc = wrappedExc.getCause();
                int oldPassed = passed;
                Class<? extends Throwable>[] excTypes = m.getAnnotation(ExceptionTest.class).value();
                for (Class<? extends Throwable> excType: excTypes) {
                    if (excType.isInstance(exc)) {
                        passed++;
                        break;
                    }
                }
                if (passed == oldPassed)
                    System.out.printf("테스트 %s 실패: %s %n", m, exc);
            }
        }
    }
    System.out.printf("성공: %d, 실패 %d%n", passed, tests - passed);

    @Repeatable
        Meta 어노테이션으로 하나의 요소에 해당 어노테이션을 여러번 달 수 있게 설정한다.

    핵심 정리.
        어노테이션은 명명 패턴보다 훨씬 낫다.
        어노테이션은 명명 패턴보다 안전하며, 클라이언트가 올바른 요소에만 적용하도록 강요할 수 있으며, 매개 변수를 전달할 수 있다.

@Override 어노테이션을 일관되게 사용하라.
    :자바가 기본으로 제공하는 어노테이션 중 가장 중요한 것은 "@Override" 어노테이션이다.
    :@Override 은 메서드 선언에만 달 수 있으며, 상위 타입의 메서드를 재정의함을 뜻한다.
    :이 어노테이션을 일관되게 사용하면 여러 가지 악명 높은 버그를 예방해준다.


    /**
     * Indicates that a method declaration is intended to override a
     * method declaration in a supertype. If a method is annotated with
     * this annotation type compilers are required to generate an error
     * message unless at least one of the following conditions hold:
     *
     * <ul><li>
     * The method does override or implement a method declared in a
     * supertype.
     * </li><li>
     * The method has a signature that is override-equivalent to that of
     * any public method declared in {@linkplain Object}.
     * </li></ul>
     *
     * @author  Peter von der Ah&eacute;
     * @author  Joshua Bloch
     * @jls 9.6.1.4 @Override
     * @since 1.5
     */
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.SOURCE)
    public @interface Override {
    }


    public class Bigram {
        private final char first;
        private final char second;

        public Bigram(char first, char second) {
            this.first = first;
            this.second = second;
        }

        public boolean equals(Bigram b) {
            return b.first == first && b.second == second;
        }

        public int hashCode() {
            return 31 * first + second;
        }

        public static void main(String[] args) {
            Set<Bigram> s = new HashSet<>();
            for (int i = 0; i < 10; i++)
                for (char c = 'a'; c <= 'z'; c++)
                    s.add(new Bigram(c, c));
            System.out.println(s.size());   //26 개여야 하지만 260 개이다. 버그가 있다!
        }
    }

    계획된 Override 와 잘못된 Overriding
        :부모 클래스의 메서드를 정의하려 했지만 (Override) 실수로 인자를 바꾸면 다중 정의 (Overloading) 이 되버린다.

    부모 메서드를 재정의할 시 @Override 을 항상 적용하라.
        :컴파일러는 프로그램의 재정의 의도를 대신 체크해주므로 심각한 버그를 피할 수 있다.
        :상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 어노테이션을 달자.

    public class Bigram {
        private final char first;
        private final char second;

        public Bigram(char first, char second) {
            this.first = first;
            this.second = second;
        }

        @Override   //컴파일러가 해당 메서드는 재정의되지 않음을 알려준다.
        public boolean equals(Bigram o) {
            return b.first == first && b.second == second;
        }

    핵심 정리.
        재정의한 모든 메서드에 @Override 어노테이션을 의식적으로 달면 우리가 실수했을 때 컴파일러가 바로 알려줄 것이다.

정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.
    :아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스(marker interface) 라 한다.
        - Serializable 인터페이스는 marker interface 이다.
            :Serializable 은 자신을 구현한 클래스의 인스턴스는 ObjectOutputStream 을 통해 write 할 수 있다고 (직렬화), 알려준다.

    마커 어노테이션과 마커 인터페이스.
        :마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 어노테이션은 그렇지 않다.
        :즉 마커 인터페이스는 런타임에 발견될 오류를 컴파일 타입에 잡을 수 있다.
        :마커 인터페이스가 나은 점 두 번째는 적용 대상을 더 정밀하게 지정할 수 있다.

    ObjectOutputStream 의 writeObject.
        :ObjectOutputStream 은 인수로 받는 객체가 Serializable (마커 인터페이스) 를 구현했을 거라고 구현한다.
        사실 ObjectOutputStream.writeObject 은 Object 인자를 받는데 사실 Serializable 인자를 받았어야 했다. (컴파일시 오류를 잡아준다)

    /**
     * Write the specified object to the ObjectOutputStream.  The class of the
     * object, the signature of the class, and the values of the non-transient
     * and non-static fields of the class and all of its supertypes are
     * written.  Default serialization for a class can be overridden using the
     * writeObject and the readObject methods.  Objects referenced by this
     * object are written transitively so that a complete equivalent graph of
     * objects can be reconstructed by an ObjectInputStream.
     *
     * <p>Exceptions are thrown for problems with the OutputStream and for
     * classes that should not be serialized.  All exceptions are fatal to the
     * OutputStream, which is left in an indeterminate state, and it is up to
     * the caller to ignore or recover the stream state.
     *
     * @throws  InvalidClassException Something is wrong with a class used by
     *          serialization.
     * @throws  NotSerializableException Some object to be serialized does not
     *          implement the java.io.Serializable interface.
     * @throws  IOException Any exception thrown by the underlying
     *          OutputStream.
     */
    public final void writeObject(Object obj) throws IOException {
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            writeObject0(obj, false);
        } catch (IOException ex) {
            if (depth == 0) {
                writeFatalException(ex);
            }
            throw ex;
        }
    }

    마커 인터페이스와 마커 어노테이션의 선택.
        :클래스와 인터페이스 외의 프로그램 요소(모듈,패키지,필드,지역변수) 에 마킹할 땐 어노테이션을 사용.
        반대로 "이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?" 라면 마커 인터페이스를 사용한다. (컴파일타임의 오류를 잡을 수 있다)

    핵심 정리.
        마커 인터페이스와 마커 어노테이션은 각자의 쓰임이 있다.
        새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 선택하자.
        클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 어노테이션을 적극 활용하는 프레임워크의 일부로 그 마커를 편입하고자 한다면 마커 어노테이션이 올바른 선택이다.
        "적용 대상이 ElementType.TYPE" 인 마커 어노테이션을 작성하고 있다면, 잠시 여유를 갖고 정말 어노테이션으로 구현하는 게 옳은지,
        혹은 "마커 인터페이스"가 낫지는 않을지 곰곰이 생각하자. (컴파일 오류 체크를 위해)
        - 해당 아이템은 ("타입을 정의할 거라면 인터페이스을 쓰라") 은 아이템 22의 "타입을 정의할 게 아니라면 인터페이스를 사용하지 말라" 와 같은 목적이다.

익명 클래스보다는 람다를 사용하라.
    예전 자바에선 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스을 선언했다.
    이런 인터페이스의 인스턴스를 "함수 객체 (function object)" 라 하여, 특정 함수나 동작을 나타나는 데 썼다. (전략 패턴의 알고리즘군 "전략")
    1997년 (JDK 1.1) 때는 함수 객체를 만드는 주요 수단 "익명 클래스"가 등장하였다.

    Comparator<String> anony =
            new Comparator<String>() {
                @Override
                public int compare(String o1, String o2) {
                    return Integer.compare(o1.length(), o2.length());
                }
            };

    전략 패턴[Gamma95]
        : Comparator 가 "추상 전략" 이라면 위의 익명 객체는 "구체 전략" 이다. Client Collection 은 "필요사항" "구현 전략"을 바꿔가면서
        특정 로직을 수행할 수 있다. "추가 전략이 구현될때마다" Collection 의 코드는 변경되지 않는다는 장점이 있다.

    예전 자바의 함수형 프로그래밍 한계.
        : 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

    자바8의 함수형 인터페이스.
        :추상 메서드 하나짜리 인터페이스.
        :람다식을 사용해 함수형 인터페이스의 인스턴스를 생성할 수 있다. (람다식 == 함수형 익명 객체)

    Comparator<String> rambda = (s1, s2) -> Integer.compare(s1.length(), s2.length());
    Collections.sort(words, rambda);

    람다에 대한 타입 추론
        아이템 26에서는 제네릭의 raw 타입을 쓰지 말라 했다. (List)
        아이템 29에서는 되도록 제네릭을 쓰라 했다. (클라이언트가 형변환 캐스팅을 사용하지 않도록 구현 - 타입 안전)
        아이템 30에서는 제네릭 메서드를 사용하라 했다. (위의 이유와 같음)
        이 조언들은 람다와 함께 쓸 때 두배로 중요해진다.
        컴파일러가 타입을 추론하는 데 필요한 타입 정보 대부분을 제네릭에서 얻기 때문이다.
        만약 위의 세개의 조언을 따르지 않으면 우리가 타입 정보를 명시적으로 제공해야 하므로 코드가 지저분해진다.

     비교자 생성 메서드.
        Comparator 에는 comparingInt 같은 정적 팩토리 메서드가 정의되어 있다.
        /**
         * Accepts a function that extracts an {@code int} sort key from a type
         * {@code T}, and returns a {@code Comparator<T>} that compares by that
         * sort key.
         *
         * <p>The returned comparator is serializable if the specified function
         * is also serializable.
         *
         * @param  <T> the type of element to be compared
         * @param  keyExtractor the function used to extract the integer sort key
         * @return a comparator that compares by an extracted key
         * @see #comparing(Function)
         * @throws NullPointerException if the argument is null
         * @since 1.8
         */
        public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {
            Objects.requireNonNull(keyExtractor);
            return (Comparator<T> & Serializable)
                (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));
        }

    람다의 간결함.
        :아이템 34 에서는 상수별 클래스 몸체를 구현하는 방식보다 열거 타입에 인스턴스 필드를 두는 편이 낫다고 했다. (또다른 원칙으론 상속보단 구성을 사용하라)
        :람다는 전략 패턴을 더 간결하게 표현시켜준다.

    enum Operation {
        PLUS("+") {
            @Override
            public double apply(double x, double y) {
                return x + y;
            }
        },
        MINUS("-") {
            @Override
            public double apply(double x, double y) {
                return x + y;
            }
        };

        private final String symbol;

        Operation(String symbol) {
            this.symbol = symbol;
        }

        public abstract double apply(double x, double y);
    }

    enum Operation {
        PLUS("+", (x, y) -> x + y),
        MINUS("-", (x, y) -> x - y);

        private final String symbol;
        private final DoubleBinaryOperator op;

        Operation(String symbol, DoubleBinaryOperator op) {
            this.op = op;
            this.symbol = symbol;
        }

        public double apply(double x, double y) {
            return op.applyAsDouble(x, y);
        };
    }

    BinaryOperator -> DoubleBinaryOperator, IntBinaryOperator
        : 같은 인수 두개를 받아 같은 타입의 인수 하나를 리턴하는 함수형 인터페이스.

    @FunctionalInterface
    public interface BinaryOperator<T> extends BiFunction<T,T,T>

    람다의 단점.
        :람다는 이름이 없고 문서화도 못하며, 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말라.
        :코드가 세 줄 이상이 넘어간다면 람다를 쓰지 말라.
        :생성자안의 람다는 클래스의 인스턴스 멤버에 접근할 수 없다. (하지만 서브 클래스의 생성자에서 부모 클래스의 인스턴스에 접근할 수 있다.)
        :람다는 함수형 인터페이스(추상 메서드가 하나만 정의된 인터페이스)에만 사용 가능하다.
        :람다는 자신을 참조할 수 없다. (람다의 this 은 바깥 인스턴스를 가리킨다 반면 익명 클래스의 this 은 익명 클래스의 인스턴스 자신을 가리킨다.)

    핵심 정리.
        작은 함수 객체를 구현할 때는 익명 클래스 보다 람다가 더 적합하다.
        익명 클래스는 함수형 인터페이스의 타입이 아닌 인스턴스를 만들 때만 만들어라.

람다보다는 메서드 참조를 사용하라.
    람다의 가장 큰 장점은 간결함이다. 하지만 자바에선 람다보다 더 간결한 메서드 참조(method reference) 가 새로 도입됬다.

    Map.merge(K key, V value,   BiFunction<? super V, ? super V, ? extends V> remappingFunction)
       :merge 함수는 키, 값, 함수를 받으며, 주어진 키가 맵에 없다면 주어진 {키, 값} 쌍을 그대로 저장하고
       키가 맵에 존재한다면 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어쓴다.
        /**
         * If the specified key is not already associated with a value or is
         * associated with null, associates it with the given non-null value.
         * Otherwise, replaces the associated value with the results of the given
         * remapping function, or removes if the result is {@code null}. This
         * method may be of use when combining multiple mapped values for a key.
         * For example, to either create or append a {@code String msg} to a
         * value mapping:
         *
         * <pre> {@code
         * map.merge(key, msg, String::concat)
         * }</pre>
         *
         * <p>If the function returns {@code null} the mapping is removed.  If the
         * function itself throws an (unchecked) exception, the exception is
         * rethrown, and the current mapping is left unchanged.
         *
         * @implSpec
         * The default implementation is equivalent to performing the following
         * steps for this {@code map}, then returning the current value or
         * {@code null} if absent:
         *
         * <pre> {@code
         * V oldValue = map.get(key);
         * V newValue = (oldValue == null) ? value :
         *              remappingFunction.apply(oldValue, value);
         * if (newValue == null)
         *     map.remove(key);
         * else
         *     map.put(key, newValue);
         * }</pre>
         *
         * <p>The default implementation makes no guarantees about synchronization
         * or atomicity properties of this method. Any implementation providing
         * atomicity guarantees must override this method and document its
         * concurrency properties. In particular, all implementations of
         * subinterface {@link java.util.concurrent.ConcurrentMap} must document
         * whether the function is applied once atomically only if the value is not
         * present.
         *
         * @param key key with which the resulting value is to be associated
         * @param value the non-null value to be merged with the existing value
         *        associated with the key or, if no existing value or a null value
         *        is associated with the key, to be associated with the key
         * @param remappingFunction the function to recompute a value if present
         * @return the new value associated with the specified key, or null if no
         *         value is associated with the key
         * @throws UnsupportedOperationException if the {@code put} operation
         *         is not supported by this map
         *         (<a href="{@docRoot}/java/util/Collection.html#optional-restrictions">optional</a>)
         * @throws ClassCastException if the class of the specified key or value
         *         prevents it from being stored in this map
         *         (<a href="{@docRoot}/java/util/Collection.html#optional-restrictions">optional</a>)
         * @throws NullPointerException if the specified key is null and this map
         *         does not support null keys or the value or remappingFunction is
         *         null
         * @since 1.8
         */
        default V merge(K key, V value,
                BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
            Objects.requireNonNull(remappingFunction);
            Objects.requireNonNull(value);
            V oldValue = get(key);
            V newValue = (oldValue == null) ? value :
                       remappingFunction.apply(oldValue, value);
            if(newValue == null) {
                remove(key);
            } else {
                put(key, newValue);
            }
            return newValue;
        }

    map.merge("hey", 1, (oldVal, newVal) -> oldVal + newVal);
        :위의 람다는 단순히 두 인수의 합을 반환하지만 코드의 공간을 꽤 차지한다.

    map.merge("hey", 1, (c, i) -> c + i);
    map.merge("hey", 1, Integer::sum);

    람다를 메서드 참조로 대체하라.
        :메서드 참조는 코드의 양을 줄이며 매개변수가 많을 수록 코드의 줄어드는 비율이 커진다.
        :하지만 메서드 참조가 더 가독성이 좋은 것은 아니다. Function::identity 보단 x -> x 의 람다가 더 가독성이 좋다.

    메서드 참조 유형.
    비한정적 참조.
        :함수 객체를 적용하는 시점에 수신 객체를 알려준다. 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다.

        정적 참조:  Integer::parseInt           람다: str -> Integer.parseInt(str)
        인스턴스 참조: Instant.now()::isAfter   람다: Instant then = Instant.now().isAfter(t)
        바한정적 참조: String::toLowerCase      람다: str -> str.toLowerCase()
        클래스 생성자 TreeMap<K,V>::new           람다: () -> new TreeMap<K,V>()
        배열 생성자 int[]::new                   람다: len -> new int[len]

표준 함수형 인터페이스를 사용하라.
    :상위 클래스의 기본 메서드를 재정의해 원하는 동작을 구현하는 템플릿 메서드 패턴(template method pattern)의 매력이 크게 줄었다.
    :템플릿 메서드 패턴 대신 함수 객체를 받는 정적 팩터리나 생성자를 제공하라.
    :이때 함수형 매개변수 타입을 올바르게 선택하라.

    LinkedHashMap 의 removeEldestEntry 메서드.
        :protected 메서드로 재정의하면 해당 맵을 캐시로 사용할 수 있다.
        맵에 새로운 키를 추가하는 put 메서드는 이 메서드를 호출하여 true 가 반환되면
        맵에서 가장 오래된 원소를 제거.

    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry<K,V> first;
        if (evict && (first = head) != null && removeEldestEntry(first)) { //removeEldestEntry 가 true 을 리턴하면, first 노트를 삭제한다.
            K key = first.key;
            removeNode(hash(key), key, null, false, true);
        }
    }

    LinkedHashMap<String, Integer> map = new CacheMap<>();
        map.put("google", 100);  //삭제
        map.put("naver", 20);
        map.put("yahoo", 15);
        map.put("test", 20);
        System.out.println(map); //google, naver, test
    }

    private static class CacheMap<K, V> extends LinkedHashMap<K, V> {
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > 3;
        }
    }

    LinkedHashMap 의 템플릿 메서드인 removeEldestEntry.
        :CacheMap 은 템플릿 메서드 패턴을 이용해 해당 메서드를 재정의하여 부모의 코드는 변경하지 않은채 원하는 동작을 구현했다.
        하지만 함수 객체를 받는 정적 팩터리나 생성자를 제공했으면 훨씬 좋을뻔했다.

  public static void main(String[] args) {
        LinkedHashMap<String, Integer> map = new CacheMap<>();
        ((CacheMap<String, Integer>) map).setRemovalFunction((m, eld) -> m.size() > 3);
        map.put("google", 100);
        map.put("naver", 20);
        map.put("yahoo", 15);
        map.put("test", 20);
        System.out.println(map);
    }

    템플릿 메서드 패턴 대체하기.
        아래의 코드는 템플릿 메서드와 같은 기능을 하는 함수형 인스턴스를 전달한다.
        상속없이 (LinkedHashMap 이 이런식으로 구현했다면) 템플릿 메서드 패턴의 효과를 대체할 수 있다.

    @FunctionalInterface
    interface EldestEntryRemovalFunction<K, V> {
        boolean remove(Map<K, V> map, Map.Entry<K, V> eldest);
    }

    private static class CacheMap<K, V> extends LinkedHashMap<K, V> {
        EldestEntryRemovalFunction<K, V> removalFunction;

        public void setRemovalFunction(EldestEntryRemovalFunction<K, V> removalFunction) {
            this.removalFunction = removalFunction;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            if (Objects.nonNull(removalFunction))
                return removalFunction.remove(this, eldest);
            else
                return false;
        }
    }

    표준 함수형 인터페이스 vs 사용자 정의 함수형 인터페이스.
        :필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하라.
            -클라이언트가 다루는 개념의 수가 줄어들어 익히기 더 쉬워진다.
            -표준 함수형 인터페이스들은 유용한 디폴트 메서드를 많이 제공한다.

    private static class CacheMap<K, V> extends LinkedHashMap<K, V> {
        BiPredicate<Map<K, V>, Map.Entry<K, V>> removalFunction;

        public void setRemovalFunction(BiPredicate<Map<K, V>, Map.Entry<K, V>> removalFunction) {
            this.removalFunction = removalFunction;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            if (Objects.nonNull(removalFunction))
                return removalFunction.test(this, eldest);
            else
                return false;
        }
    }


    java.util.function 의 43개 함수형 인터페이스.
        :기본 인터페이스 6개만 기억하면 나머지는 충분히 유추할 수 있다.

    Operator
        : 인수의 타입과 반화값이 같은 함수를 뜻한다.
        UnaryOperator
            : 인수가 1개인 인수와 반환값의 타입이 같은 함수형 인터페이스.
        BinaryOperator
            : 인수가 2개인 인수들과 반화값의 타입이 같은 인터페이스.
    Predicate
        : 인수를 받아 boolean을 반환하는 함수.
    Function
        :인수들의 타입과 반환 타입이 다른 함수.
    Supplier
        :인수를 받지 않고 값을 반환하는 함수.
    Consumer
        :인수를 하나 받고 반환값은 없는 함수.
    int, long, double 전용 인터페이스들.
        :성능상의 지원을 위해 기본 타입 전용 인터페이스들이 있다.
        Predicate -> IntPredicate, BinaryOperator -> LongBinaryOperator
        Function 인터페이스만이 유일하게 "매개변수화" 되었다.
            -DoubleFunction<int[]> 은 double 인수를 받아 int[] 을 반환한다.

        @FunctionalInterface
        public interface DoubleFunction<R> {

            /**
             * Applies this function to the given argument.
             *
             * @param value the function argument
             * @return the function result
             */
            R apply(double value);
        }
        Function 인터페이스에는 기본 타입을 반환하는 변형이 총 9개 있다.
        Function 인터페이스의 변형은 입력과 결과의 타입이 항상 다르다. (기본 Function 이 그러하듯)
        입력과 결과 타입이 모두 기본 타입이면 SrtToResult 을 사용한다.
            - LongToIntFunction
        반대로 입력이 객체 참조이고 결과가 기본 타입이면 ToResult 을 사용한다.
            - ToLongFunction<int[]> 라면 int[] 인수를 받아 long 을 리턴한다.
            BiFunction 을 예로 들다.

    UnaryOperator<T>    T apply(T t)            String::toLowerCase
    BinaryOperator<T>   T apply(T t1, T t2)     BigInteger::add
    Predicate<T>        boolean test(T t)       Collection::isEmpty
    Function<T,R>       R apply(T t)            Arrays::asList
    Supplier<T>         T get()                 Instant::now
    Consumer<T>         void accept(T t)        System.out::println

    함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자.
        :계산량이 많을 때는 성능이 "처참히 느려질 수 있다.".

    기본 함수형 인터페이스 외에 커스텀 인터페이스를 직접 작성해야 할때는?
        :필요한 용도에 맞는 인터페이스가 없던가, 검사 예외를 던지는 경우.
        :"자주 쓰이며", 이름 자체가 용도를 명확히 설명.
        :반드시 따라야 하는 규약이 있다.
        :유용한 디폴트 메서드를 제공할 수 있다.

    @FunctionalInterface 을 항상 사용하라.
        :이 어노테이션의 기능은 @Override 을 사용하는 이유와 비슷하다.
        그 인터페이스가 람다용으로 설계됨을 알려주고, 해당 인터페이스가 하나의 추상 메서드를 가짐을 강제한다.
        :컴파일시 실수로 메서드를 추가하지 못하게 막아주어 버그를 방지한다.

    함수형 인터페이스를 선언할 같은 위치의 인수로 받는 "다중 정의"는 피하라.

    핵심 정리.
        람다를 설계하는 것은 API 을 설계하는 것과 같다.
        입력값과 반환값에 맞추어진 인터페이스 타입을 활용하라.
        java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.

스트림은 주의해서 사용하라.
    스트림 api 은 다량의 데이터 처리 작업("순차적" 혹은 "병렬적")을 수행한다.

    스트림 (Stream).
        :데이터 원소의 유한 혹은 무한 "시퀀스".
        즉 연속적으로 이어진 유무한의 데이터들.
        시퀀스
            :일련(하나로 이어지는)의 연속적인 사건 혹은 사건이나 행동들의 순서.

    스트림 파이프라인(Stream pipeline)
        :스트림의 원소들에 수행할 연산 단계를 표현.

    스트림의 시작과 끝.
        :소스 스트림, 중간 연산(intermediate operation -(transform,filter)), 종단 연산(terminal operation)

    스트림의 지연 평가.
        :평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 도달하지 못한(쓰이지 않은) 데이터 원소는 계산에 쓰이지 않는다.
        :즉 스트림은 종단 연산이 호출되지 않으면 아무 일도 하지 않는다.

    스트림과 병렬성.
        - 스트림은 기본저긍로 순차적으로 수행. 파이프라인을 병렬로 실행하려면 parallel 메서드를 호출하라 (단 효과를 볼 상황은 많지 않다).

    Scanner(File source).
        소스 파일로부터 데이터를 읽어 Scanner 을 생성한다.

        /**
         * Constructs a new <code>Scanner</code> that produces values scanned
         * from the specified file. Bytes from the file are converted into
         * characters using the underlying platform's
         * {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.
         *
         * @param  source A file to be scanned
         * @throws FileNotFoundException if source is not found
         */
        public Scanner(File source) throws FileNotFoundException {
            this((ReadableByteChannel)(new FileInputStream(source).getChannel()));
        }

    Map.computeIfAbsent
        : 맵 안에 키가 있다면 키에 매핑된 값을 반환하고, 키가 없다면 건네진 함수 객체를 키에 적용하여 값을 계산한 다음
        그 키와 값을 매핑해놓고, 계산된 값을 반환한다.

    default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) { // 키가 없다면 인자로 받은 함수로 계산한다.
                put(key, newValue); //계산된 값과 주어진 키를 맵에 넣는다.
                return newValue;
            }
        }
        return v;
    }

    스트림을 과하게 사용하지 마라.
        : 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.
        : 스트림을 적당히 사용하여 코드의 행위가 명확하게 보여지도록 하라.
        : 스트림의 가독성을 높이기 위해선 람다의 매개변수 이름을 주의해서 지어라.
        : 연산이 복잡하다면 메서드로 빼내어 적절한 메서드 이름을 지어주라.


        public static void main(String[] args) throws IOException {
            Path dictionary = Paths.get("anagrams");
            int minGroupSize = Integer.parseInt("4");
            try (Stream<String> words = Files.lines(dictionary)) {
                words.collect(groupingBy(word -> word.chars().sorted().collect(StringBuilder::new, (sb, c) -> sb.append((char) c), StringBuilder::append).toString()))
                        .values().stream().filter(group -> group.size() >= minGroupSize)
                        .map(group -> group.size() + ": " + group)
                        .forEach(System.out::println);
            }
        }

        public static void main(String[] args) throws IOException {
            Path dictionary = Paths.get("anagrams");
            int minGroupSize = 4;
            try (Stream<String> words = Files.lines(dictionary)) {
                words.collect(groupingBy(Anagrams::alphabetize)) //Stream<List<String>>
                //words.collect(groupingBy(Anagrams::alphabetize, toSet())) //Stream<Set<String>>
                        .values().stream()
                        .filter(group -> group.size() >= minGroupSize)1
                        .forEach(group -> System.out.println(group.size() + ": " + group));
            }
        }

        private static String alphabetize(String s) {
            char[] a = s.toCharArray();
            Arrays.sort(a);
            return new String(a);
        }


    Files.lines(path)
        :해당 파일로부터 모든 라인의 데이터를 Stream 읽어온다.

    public static Stream<String> lines(Path path, Charset cs) throws IOException {
        BufferedReader br = Files.newBufferedReader(path, cs);
        try {
            return br.lines().onClose(asUncheckedRunnable(br));
        } catch (Error|RuntimeException e) {
            try {
                br.close();
            } catch (IOException ex) {
                try {
                    e.addSuppressed(ex);
                } catch (Throwable ignore) {}
            }
            throw e;
        }
    }

    스트림의 평준화.
        :flatMap 은 스트림의 원소 각각을 하나의 스트림으로 매핑한 다음 그 스트림들을 다시 하나의 스트림으로 합친다.
        이를 평탄화(flattening) 이라 한다


        private static List<Card> newDeck() {
            List<Card> result = new ArrayList<>();
            for (Card.Suit suit: Card.Suit.values())
                for (Card.Rank rank: Card.Rank.values())
                    result.add(Card.of(suit, rank));
            return result;
        }

        private static List<Card> newDeckByStream() {
            return Stream.of(Card.Suit.values()) //Stream<Suit>
                    .flatMap(suit ->
                        Stream.of(Card.Rank.values())
                            .map(rank -> Card.of(suit, rank)))
                    .collect(toList());
        }

    핵심 정리.
        스트림을 사용해야 멋지게 처리할 수 있는 일이 있고, 반복 방식이 더 알맞는 일도 있다.
        보통은 이 둘을 조합해야 가장 멋지게 해결된다.
        스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은쪽을 택하라.

스트림에서는 부작용 없는 함수를 사용하라.
    :스트림의 병렬성을 얻으려면 순수 함수여야 한다.

    순수 함수
        :오직 입력만이 결과에 영향을 주는 함수.
        :다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다.
        :스트림 연산에 건네는 함수 객체는 모두 부작용(side effect)이 없어야 한다.

    Map<String, Long> freq = new HashMap<>();
    Path filePath = Paths.get("anagrams");
    try (Stream<String> words = Files.lines(filePath)) {
        words.filter(m -> !"".equals(m))
                .forEach(word -> freq.merge(word, 1L, Long::sum));
    }

    순수 함수만을 이용하는 람다.
        :forEach 은 종단 연산 중 기능이 가장 적고 가장 '덜' 스트림답다.
        forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 사용하지 마라.

    Map<String, Long> freq;
    Path filePath = Paths.get("anagrams");
    try (Stream<String> words = Files.lines(filePath)) {
        freq = words.filter(word -> !"".equals(word))
                .collect(groupingBy(String::toLowerCase, counting()));
    }

    스트림의 수집기(Collector)
        :스트림을 사용하려면 꼭 배워야 하는 개념이다.
        :축소(reduction) 전략을 캡슐화한 블랙박스 객체이다.
        :축소(reduction) 이란 스트림의 원소들을 객체 하나에 모은다는 ㅡㄸㅅ이다.

        Collector (수집기)의 종류.
            toList(), toSet(), toCollection(collectionFactory)

    Collectors 의 구현체 CollectorImpl


    new CollectorImpl<>((Supplier<List<T>>) ArrayList::new, //컬렉션 Factory
                        List::add,                          //Accumulator
                        (left, right) -> { left.addAll(right); return left; },  //Combiner
                        CH_ID)                              //Characteristics
    /**
     * Simple implementation class for {@code Collector}.
     *
     * @param <T> the type of elements to be collected
     * @param <R> the type of the result
     */
    static class CollectorImpl<T, A, R> implements Collector<T, A, R> {
        private final Supplier<A> supplier;
        private final BiConsumer<A, T> accumulator;
        private final BinaryOperator<A> combiner;
        private final Function<A, R> finisher;
        private final Set<Characteristics> characteristics;

        CollectorImpl(Supplier<A> supplier,
                      BiConsumer<A, T> accumulator,
                      BinaryOperator<A> combiner,
                      Function<A,R> finisher,
                      Set<Characteristics> characteristics) {
            this.supplier = supplier;
            this.accumulator = accumulator;
            this.combiner = combiner;
            this.finisher = finisher;
            this.characteristics = characteristics;
        }

        CollectorImpl(Supplier<A> supplier,
                      BiConsumer<A, T> accumulator,
                      BinaryOperator<A> combiner,
                      Set<Characteristics> characteristics) {
            this(supplier, accumulator, combiner, castingIdentity(), characteristics);
        }

    List<String> topThree = freq.keySet().stream()
            .sorted(comparing(freq::get).reversed())
            .limit(3)
            .collect(toList());

    맵 수집기 (Map Collector)
        :가장 간단한 맵 수집기로 Collectors.toMap(keyMapper, valueMapper) 가 있다.
        :Collectors.toMap 은 각 원소가 고유한 키 (1:1 관계)에 매핑되어 있을 때 적합한다.
        :즉 스트림 원소 다수가 같은 키를 사용한다면 IllegalStateException 을 던진다.
        :keyMapper, valueMapper, merge 함수까지 제공할 수 있다.

        인수가 2개인 toMap (Collectors.toMap(keyMapper, valueMapper))
            public static <T, K, U>
            Collector<T, ?, Map<K,U>> toMap(Function<? super T, ? extends K> keyMapper,
                                            Function<? super T, ? extends U> valueMapper) {
                return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new); //
            }

            private static <T> BinaryOperator<T> throwingMerger() {
                return (u,v) -> { throw new IllegalStateException(String.format("Duplicate key %s", u)); };  // 스트림의 원소 다수가 같은 키를 사용하면 예외가 발생.
            }

        인수가 3개인 toMap (병합 함수를 받는 Collectors.toMap(keyMapper, valueMapper, mergeFunction))
            : 병합 함수 (merge function) 의 형태는 BinaryOperator<U> (인자와 리턴 타입이 같은 함수), 여기서 U는 값의 타입이다.
            같은 키를 공유하는 값들은 이 병합 함수를 사용해 기존 값에 합쳐진다.

            public static <T, K, U>
            Collector<T, ?, Map<K,U>> toMap(Function<? super T, ? extends K> keyMapper,
                                            Function<? super T, ? extends U> valueMapper,
                                            BinaryOperator<U> mergeFunction) {
                return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new);
            }

            albums.stream().collect(toMap(Album::artist, e -> e, new BinaryOperator<Album>() {  //merge function 을 이용해 값 Album 중 가장 sales 가 큰 놈만 골라 리턴.
                        @Override
                        public Album apply(Album album, Album album2) {
                            return album.sales >= album2.sales ? album : album2;
                        }
                    }));

            Map<Artist, Integer> total = albums.stream().collect(toMap(Album::artist, e -> a- > a, maxBy(comparing(Album::sales));
                :"앨범 스트림을 맵으로 바꾸는데, 이 맵은 각 음악가와 그 음악가의 베스트 앨범을 짝 지은 것이다."

            Map<Artist, Album> bestAlbum = albums.stream().collect(toMap(Album::artist, e -> e, BinaryOperator.maxBy(comparing(Album::sales))));
            Map<Artist, Integer> totalAlbum = albums.stream().collect(toMap(Album::artist, e -> e.sales, Integer::sum));
            Map<Artist, Album> recentAlbum = albums.stream().collect(toMap(Album::artist, e -> e, (oldValue, newValue) -> newValue));


        인수가 4개인 toMap (네 번째 인수로 맵 팩토리를 받는 Collector.toMap(keyMapper, valueMapper, mergeFunction, mapSupplier))
            :마지막 인수로 EnumMap 이나 TreeMap 처럼 특정 맵 구현체를 지정할 수 있다.

    Collectors.groupingBy
        : 입력으로 분류 함수(classifier) 을 받고 출력으로 원소들을 분류 함수를 이용해 카테고리별로 모아 놓은 맵을 담은 수집기를 반환한다.

        인수가 하나인 Collectors.groupingBy(Function classifier)
            :스트림의 원소를 분류 함수를 이용한 카테고리에 분류하여 맵 형태로 반환한다. 반환된 맵에 담긴 각각의 값은 해당 카테고리에 속하는 원소들을 리스티이다.
        인수가 두개인 Collectors 의 downstream.
            :해당 스트림의 결과값인 Map 의 값 을 생성한다.
            : 다음스트림 수집기의 역할은 해당 카테고리의 모든 원소를 담은 스트림으로부터 값을 생성하는 일이다.
            : 다음스트립 수집기의 가장 간단한 방법은 toSet(), toCollection(collectionFactory) 을 건네는 방법이다.

            words.filter(not(String::isEmpty)).collect(groupingBy(word -> alphabetize(word), Collectors.counting()));

    partitioningBy
        : groupingBy 의 사촌격으로 분류 함수 자리에 predicate 을 받고 키가 Boolean 인 맵을 반환한다.

    핵심 정리.
        스트림 파이프라인 핵심은 부작용 없는 함수 객체에 있다.
        스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다.
        forEach 은 계산 결과를 보고할 때만 이요해야 한다.
        스트림을 올바로 사용하려면 수집기를 잘 알아둬야 한다.

반환 타입으로는 스트림보다 컬렉션이 낫다.
    :클라이언트는 스트림만 반환하도록 짜놓은 API를 for-each 문을 사용하고 싶을 수 있다.
    :사실 Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함할 뿐만 아니라, Iterable 인터페이스가 정의한 방식대로 동작한다.
    :반대로 Stream 의 iterator 은 Iterable 인터페이스와 기대한 같은 기능을 하지만 확장하진 않았다.

    Iterable 과 Iterator
        :Iterable 은 iterator 인터페이스를 반환하는 순회 가능한 컬렉션 객체이다.
        :Iterator 은 Iterable 에서 생성 가능하며 순회를 하는 객체이다.

    public interface BaseStream<T, S extends BaseStream<T, S>> extends AutoCloseable {
        /**
         * Returns an iterator for the elements of this stream.
         *
         * <p>This is a <a href="package-summary.html#StreamOps">terminal
         * operation</a>.
         *
         * @return the element iterator for this stream
         */
        Iterator<T> iterator(); //Iterator 을 반환한다!

    Stream<E> 을 Iterable<E> "어댑터 패턴"을 이용하여 변환.
    public static <E> iterable<E> iteratorOf(Stream<E> stream) {
        return stream::iterator;
    }

    반대로 Iterable<E> 를 Stream<E> 로 변환하는 "어댑터 메서드 패턴"

    Spliterator
        :Spliterator 는 '분할할 수 있는 반복' 로, 기존 존재했던 반복자인 Iterator 와 비슷하지만 병렬 작업에 특화된 인터페이스.

    StreamSupport.stream
        :spliterator 로부터 스트림을 생성한다.
        public static <T> Stream<T> stream(Spliterator<T> spliterator, boolean parallel)

    public static <E> Stream<E> streamOf(Iterable<E> iterable) {
        return StreamSupport.stream(iterable.spliterator(), false);
    }

     하지만 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection 이나 그 하위 타입을 쓰는게 최선이다.
        :Collection 인터페이스는 Iterable의 하위 타입이고 stream 메서드도 제공하니 클라이언트는 입맞에 맞췃 사용할 수 있다.
        :배열 역시 Arrays.asList 와 Stream.of 메서드로 손쉽게 Iterable 과 스트림을 지원할 수 있다.

     //Collection.stream 메서드를 이용하면 Iterable 와 Stream 을 모두 사용할 수 있다.
    /**
     * Returns a sequential {@code Stream} with this collection as its source.
     *
     * <p>This method should be overridden when the {@link #spliterator()}
     * method cannot return a spliterator that is {@code IMMUTABLE},
     * {@code CONCURRENT}, or <em>late-binding</em>. (See {@link #spliterator()}
     * for details.)
     *
     * @implSpec
     * The default implementation creates a sequential {@code Stream} from the
     * collection's {@code Spliterator}.
     *
     * @return a sequential {@code Stream} over the elements in this collection
     * @since 1.8
     */
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }

    하지만 덩치 큰 시퀀스를 컬렉션으로 반환하여 메모리에 올려서는 안된다.
        :메모리가 많이 필요하다면 비트 벡트와 같은 방식을 사용하라.
        :AbstractList 을 활용하면 훌륭한 전용 컬렉션을 손쉽게 구현 가능하다.

    비트벡터.
        비트 벡터란 중복되지 않는 정수 (혹은 char) 집합을 비트로 나타내는 방식

        아래 코드의 공간 복잡도은 O(n) 이다.
        boolean isUniqueChars(String str) {
            boolean[] alphabet_set = new boolean[26];
            for (int i = 0; i < str.length(); i++) {
                int val = str.charAt(i) - 'a';
                if (alphabet_set[val])
                    return false;
                alphabet_set[val] = true;
            }
            return true;
        }

        하지만 아래 코드의 공간 복잡도는 O(1) 이다. int 하나만을 사용하므로.
        boolean isUniqueChars(String str) {
            int checker = 0;
            for (int i = 0; i < str.length(); i++) {
                int val = str.charAt(i) - 'a';
                if ((checker & (1 << val)) > 0)
                    return false;
                checker |= (1 << val);
            }
            return true;
        }

        AbstractCollection 을 활용해 Collection 구현체를 작성 할때는
        Iterable 용 메서드 외에 contains 와 size 을 구현하면 된다.

        리스트의 모든 부분리스트를 스트림으로 구현하기.
            1. 첫 번째 원소를 포함하는 부분리스트를 생성한다.
            2. 마지막 원소를 포함하는 부분리스트를 생성하여 첫번째 리스트와 합친다.
    Stream.concat
        :두 스트림을 하나로 합친다.
    IntStream.range 을 이용하면 해당 int 원소를 특정 컬렉션의 원소를 접근 하기위한 인덱스로 사용할 수 있다.
    IntStream.rangeClosed 은 IntStream.range 와 기능이 같지만 마지막 index 을 포함한다.

    핵심 정리.
        원소 시퀀스를 반환하는 메서드를 작성할 때는, 대부분 컬렉션을 반환하는게 좋은 선택이다. (컬렉션은 Iterable, Stream 모두 지원하므로)
        너무 큰 컬렉션을 반환한다면 비트 벡터와 전용 컬렉션 (Abstract 컬렉션을 구현한) 을 구현하여 반환하라.

스트림 병렬화는 주의해서 사용하라.
    자바는 스레드, 동기화, wait/notify 그리고 Java 5 에선 java.util.concurrent 라이브러리와 Executor 프레임워크를 지원함으로써 동시성 프로그래밍을 지원한다.
    자바 7부터는 고성능 병렬 분해(parallel decom-position) 프레임워크인 포크-조인(fork-join) 패키지를 추가했다.
    자바 8부터는 parallel 메서드만 한 번 호출하면 "파이프라인을 병렬" 실행할 수 있는 스트림을 지원한다.

    Stream.iterate
        :f 함수를 초기 요소 시드에 반복적으로 적용하여 생성된 무한 순차 순서 스트림을 반환

    /**
     * Returns an infinite sequential ordered {@code Stream} produced by iterative
     * application of a function {@code f} to an initial element {@code seed},
     * producing a {@code Stream} consisting of {@code seed}, {@code f(seed)},
     * {@code f(f(seed))}, etc.
     *
     * <p>The first element (position {@code 0}) in the {@code Stream} will be
     * the provided {@code seed}.  For {@code n > 0}, the element at position
     * {@code n}, will be the result of applying the function {@code f} to the
     * element at position {@code n - 1}.
     *
     * @param <T> the type of stream elements
     * @param seed the initial element
     * @param f a function to be applied to to the previous element to produce
     *          a new element
     * @return a new sequential {@code Stream}
     */
    public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)

    BigInteger.nextProbablePrime
        : 현재 BigInteger 보다 바로 등장하는 소수를 리턴.

    동시성 프로그래밍을 할 때는 안정성(safety) 와 응답 가능(liveness) 상태를 유지하기 위해 힘써야 한다.

    데이터 소스가 Stream.iterate 거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없다.
        :Stream 의 파이프라인은 limit 을 다룰 때 CPU 코어가 남는다면 "원소를 몇 개 더 처리한 후" 제한된 개수 이후의 결과는 버리는 식으로 처리한다.
        예를들어 1부터 20까지 비싼 연산이 들어가는 계산을 하는데 코어 시스템에서 19번째 계산을 마치고 마지막 20번째 계산이 수행되는 시점에
        코어 3개가 한가하다. 21, 22, 23번째 메르센 소수를 찾는 작업이 병렬로 시작되는데, 20번째 계산이 끝나더라도 이미 시작된 계산들이 끝날때까지 기다린다.

    스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap 의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다.
        : 해당 자료구조들은 모두 데이터를 원하는 크기로 정확하고 손쉽게 여러 쓰레들에게 분배할 수 있기 때문이다.
        : 해당 자료 구조들의 공통점은 원소의 참조들이 메모리에 연속되어 저장되어 있기에 빠르다. (ArrayList, HashMap 등 구현은 배열로 되어있다) 반대로 LinkedList은 느리겠네.
        : 참조 지역성이 낮으면 스레드는 데이터가 주 메모리(heap)에서 캐시 메모리(쓰레드 stack) 로 전송되기 오기를 기다리며 대부분 시간을 버린다.
    스트림의 종단 연산의 동작 방식 역시 병렬 수행 효율에 영향을 준다.
        : reducing 연산, min, max, count sum 같은 스트림 병렬화 처리에 적합하다.
        : anyMatch, allMatch, noneMatch 처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다.
        : collect 메서드는 병려로하에 적합하지 않다.
    Stream 에서 프로그래머가 제공한 다름 함수 객체를 순수 함수로 정의하는 방법이다.
        결합 법칙을 만족하라.
            (a op b) op c == a op (b op c)
            (a + b)  + c = a + (b + c)
            if (a == b) and (b == c) then (a == c)
        간섭 받지 마라.
            : 파이프라인이 수행되는 동안 데이터 소스가 변경되지 말아야 한다.
        상태를 갖지 않아야 한다.

    핵심 정리.
        계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이 스트림 파이프라인 병렬화를 시도하지 마라.

메서드
매개변수가 유효한지 검사하라.
    :메서드는 입력 매개변수의 값이 특정 조건을 만족함을 기대한다.
    :이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다.
    :"오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다"


    매개변수 검사를 제대로 하지 못하면 (혹은 최대한 빨리 잡지 못하면) 발생할 문제.
        1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
        2. 메서드가 잘 수행되지만 잘못된 결과를 바노한한다.
        3. 메서드는 문제없이 수행됐지만, 어떤 객체를 "이상한 상태"로 만들어 놓아 미래의 알 수 없는 시점에 이 메서드와 관련 없는 오류를 낼 때.
            :매개변수 검사에 실패하면 실패 원자성(failure atomicity) 을 어기는 결과를 넣는다.

    "public 과 protected 메서드"는 매개변수 값이 잘못됐을 때 던지는 "예외를 문서화"해야 한다.
        :@throws 자바독 태그로 던지는 예외를 문서화하라.
        :NullPointException 이 모든 메서드에서 던져진다면 클래스 수준 주석에 문서화하라.

     * Returns a BigInteger whose value is {@code (this mod m}).  This method
     * differs from {@code remainder} in that it always returns a
     * <i>non-negative</i> BigInteger.
     *
     * @param  m the modulus.
     * @return {@code this mod m}
     * @throws ArithmeticException {@code m} &le; 0
     * @see    #remainder
     */
    public BigInteger mod(BigInteger m) {
        if (m.signum <= 0)
            throw new ArithmeticException("BigInteger: modulus not positive");

        BigInteger result = this.remainder(m);
        return (result.signum >= 0 ? result : result.add(m));
    }

    Objects.requireNonNull
        :null 검사를 수동으로 하지 않아도 된다. 입력을 그대로 반환하므로 값을 사용하는 동시에 null 검사를 수행할 수 있다.ㅏ
        Object strategy = Objects.requireNonNull(nullable, "strategy");
    Objects.checkFromIndexSize,

    "package-private" 메서드는 assert 문을 사용해 매개변수 유효성을 검증하라.
        :개발자 스스로가 메서드가 호출되는 상황을 통제할 수 있으므로, 오직 유효한 값만이 넘겨지리라는 것을 보증할 수 있고, 그렇게 해야 한다.
        :assert 을 사용해 매개변수 유효성을 검증하라.
        :다시 말해 package-private 문으로 넘어오는 매개변수들은 자신이 단언한 조건이 무조건 참이라고 선언하는 것이다.

    private static void sort(long[] a, int offset, int length) {
        assert a != null;
        assert offset >= 0 && offset <= a.length;
        assert length >=0 && length <= a.length - offset;
        ... // 계산 수행.
    }

    Assert 문
        : assert (조건문) 식으로 무조건 참이여만 하는 조건을 명시한다.
        : 실패하면 AssertionError 을 던진다.
        : 런타임에 아무런 효과도, 아무런 성능 저하도 없다.
        : -ea 혹은 --enableassertions 플래그 설정하면 영향을 준다.

    매개변수 유효성 체크의 유일한 예외.
        1. 메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수.
        2: 유효성 검사 비용이 자니치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때.
            :Collections.sort(Lit) 은 모두 정렬 과정에서 비교가 이뤄진다.
            :만약 상호 비교될 수 없는 타입의 객체가 들어 있다면 객체와 비교할 때 ClassCastExceptino 이 던져진다.
            :비교하기 앞서 리스트 안의 모든 객체가 상호 비교될 수 있는지 검사해봐야 별다른 실익이 없다.
            :하지만 암묵적 유효성 검사에 너무 의존하면 실패 원자성을 해칠 수 있으니 주의하라.
            :또한 계산 도중에 API 문서에 던지기로 한 예외가 다르다면 예외 번역(exception translate) 관용구를 사용해 문서에 기재된 예외로 번역하라.

        List<Integer> array = intArrayAsList(null);
        array.get(0);
        }

        public static List<Integer> intArrayAsList(int[] a) {
            //해당 검사를 하지않으면 클라이언트가 돌려받는 List 을 사용할 때 예외가 발생한다.
            //Objects.requireNonNull(a);
            return new AbstractList<Integer>() {
                @Override
                public Integer set(int i, Integer val) {
                    int oldVal = a[i];
                    a[i] = val;
                    return oldVal;
                }

                @Override
                public int size() {
                    return a.length;
                }

                @Override
                public Integer get(int i) {
                    return a[i];
                }
            };
        }

        메서드는 최대한 범용적으로 설계하되 메서드 유효 검사는 정확히 하라.
            :메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다.
            :필요한 제약만을 검사하라. 또한 매개변수를 줄여라.

    핵심 정리.
        메서드나 생성자를 작성할 때면 그  매개변수들에 어떤 제약이 있을지 생각해야 한다.
        그 제약들을 문서화하고 메서드 코드 시작 부분에 명시적으로 검사하라.
        이는 습관을 길러야 실행할 수 있다.
        그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

적시에 방어적 복사본을 만들라.
    :클라이언트가 너의 불변식을 깨트리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍하라.
    :어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하다.

    얼핏보다 아래 클래스는 불변같다.
    public final class Period {

        private Date start;
        private Date end;
        /**
         * @param start 시작 시각
         * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
         * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
         * @throws NullPointerException start 나 end 가 null 이면 발생한다.
         */
        public Period (Date start, Date end) {
            if (start.compareTo(end) > 0)
                throw new IllegalArgumentException();
            this.start = start;
            this.end = end;
        }

        public Date start() {
            return start;
        }

        public Date end() {
            return end;
        }
    }

    하지만 클래스에서 규정한 불변식이 이렇게 깨진다.
    public static void main(String[] args) {
        Date start = new Date();
        Date end = new Date();
        Period p = new Period(start, end);
        end.setYear(78); //불변식이 깨졌다.
    }

    Date은 낡은 API이니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.
        :Date 가 필요하다면 LocalDateTime 이나 Instant 을 사용하라. 불변이고 더 강력하다.

    외부 공격으로부터 클래스의 "불변식"을 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사 (defensive copy) 하라.
    public final class Period {

    private Date start;
    private Date end;
    /**
     * @param start 시작 시각
     * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
     * @throws NullPointerException start 나 end 가 null 이면 발생한다.
     */
    public Period (Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException();
    }

    매개변수의 유효성 검사하기전에 방어적 복사본을 만들고, 이 복사본으로 유효성 검사하라.
        :멀티쓰레딩 환경이라면 유효성 검사한 후 복사본을 만드는 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있다.

    매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.

    가변 필드 ("방어적 복사본") 을 외부로 노출하지 마라.
        :외부로 가변 필드를 노출해야 한다면 다시 "방어적 복사본" 을 생성하여 반환하라.
    public final class Period {

        public static void main(String[] args) {
            Date start = new Date();
            Date end = new Date();
            Period p = new Period(start, end);
            p.end().setYear(78);  // 불변식이 또 깨졌다.
            System.out.println(p.end());
        }

        private Date start;
        private Date end;
        /**
         * @param start 시작 시각
         * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
         * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
         * @throws NullPointerException start 나 end 가 null 이면 발생한다.
         */
        public Period (Date start, Date end) {
            if (start.compareTo(end) > 0)
                throw new IllegalArgumentException();
            this.start = new Date(start.getTime());
            this.end = new Date(end.getTime());
        }

        public Date start() {
            return start;
        }

        public Date end() {
            return end;
        }

    접근자에서 방어적 복사본을 생성하여 리턴하라.
        public Date start() {
            return new Date(start.getTime());
        }

        public Date end() {
            return new Date(end.getTime());
        }

    생성자, 팩토리에서 방어적 복사본을 생성하여 저장하고 접근자에서도 방어적 복사본을 생성하여 리턴하라.
        :그래야만 객체의 완벽한 캡슐화가 이루어진다.

    방어적 복사본의 목적은 "불변 객체"를 만들기 위해서만은 아니다.
        :클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각하라.
        변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 "임의의 변경" 되어 그 클래스가 문제없이 동작("불변식을 위배할지")를 따져봐라.
        확신할 수 없다면 복사본을 만들어 저장하라. (모든 상황을 다 예측할 순 없다. 무조건 방어적 복사본을 만들어라)
        :가변인 내부 객체를 클라이언트에 반환할 때도 반드시 심사숙고하라.
        :배열은 무조건 가변임을 잊지 말자.
        :"불변 객체들을 조합해" 객체를 구성하면 방어적 복사를 할 일이 줄어드므로 성능이 좋아진다.

    핵심 정리.
        클래스가 클라이언트로 받는 혹은 클라리언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다.
        복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사 대신 문서에 명시하도록 하자.

메서드 시그니처를 신중히 설계하라.
    메서드 이름을 신중히 짓자.
        :항상 표준 명명 규칙(아이템 68) 을 따르라.
        :이름이 애매하다면 자바 라이브러리의 API 가이드를 참조하라. (대부분은 표준 명명 규칙을 지키므로 아이디어를 얻을 수 있다.)
    편의 메서드를 너무 많이 만들지 말자.
        :모든 메서드는 "각각 자신의 소임"을 다해야 한다.
        :메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다.
        :흠
    매개변수 목록은 짧게 유지하자.
        :4개 이하가 좋다. 4개가 넘어가면 매개변수를 전부 기억하기 어렵다.
        :같은 타입의 매개변수가 어러 개가 연달아 나오는 경우가 특히 해롭다. 매개변수 순서를 기억하기 어려울뿐더라, 실수로 순서를 바꾸는 경우가 많다.
        :이를 피하기 위해 여러 메서드로 쪼갠다.
            하나의 메서드를 만들기 위해 두 메서드를 만들어 호출하라는 것이 아니다.
            아예 두 기능을 만들어 "클라이언트에게 노출하"라.
            "기능을 원자적으로 쪼개 제공하라"

            List 의 특정 범위안에서 특정 원소를 찾는다고 가장해보자.
            매개변수는 부분리스트의 사작, 부분리스트의 끝, 찾을 원소 까지 3개가 필요하다.
            이런 경우 subList 으로 부분 리스트를 리턴하는 메서드와
            indexOf 라는 메서드를 제공하면 클라이언트는 원하는 메서드를 사용하는 것 외에 두가지 메서드를 가지는 더 큰 유연함을 가진다.

        :위의 방법으로도 매개변수를 쪼갤 수 없다면 도우미 클래스를 만들어라
    매개변수의 타입으로는 클래스보다 인터페이스가 낫다.
        :매개변수로 적합한 인터페이스가 있다면 인터페이스를 직접 사용하자.
        :인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이니,
        혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사 비용을 치러야 한다.

    매개변수로 boolean 보다는 원소 2개짜리 열거 타입이 낫다.
        :나중에 추가적인 옵션이 추가된다면 호출하는 boolean 매개변수는 모두 바껴야 된다. Enum 은 원소만 추가하면 된다.


가변인수는 신중히 사용하라.
    :가변인수 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있다.
    :가변인수 메서드를 호출하면, "인수의 개수와 길이가 같은 배열을 만들고" 인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.

    인수를 1개 이상 받아야할 때 가변인수 하나만 받는 메서드를 설계하지 마라.
        : 인수가 0개를 넣는다면 런타임에 실패한다.
        : 인수가 1개 이상이라면 첫번째 인자로 default value 을 받으라.
    static int min(int... args) {
        if (args.length == 0)
            //런타임 예외가 발생한다.
            throw new IllegalArgumentException("인수가 1개 이상 필요합니다.");
        int min = args[0];
        for (int i = 1; i < args.length; i++)
            if (args[i] < min)
                min = args[i];
        return min;
    }

    static int min(int firstArg, int... args) {
        int min = firstArg;
        for (int arg: args)
            if (arg < min)
                min = arg;
        return min;
    }

    성능이 민감할땐 가변인수를 사용하지 마라.
        :가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화한다.
        :만약 인수 개수가 정해지지 않을때 꼭 가변인수를 사용해야 하고,
        메서드 호출의 90%가 가변 인수가 3개 이하로 호출한다면 아래 패턴을 이용하라.

        public void foo() { }
        public void foo(int a) { }
        public void foo(int a, int b) { }
        public void foo(int a, int b, int c) { }
        public void foo(int a, int b, int c, int... rest) { }

        :EnumSet.of 또한 이 패턴을 이용한다.

        public static <E extends Enum<E>> EnumSet<E> of(E e) {
            EnumSet<E> result = noneOf(e.getDeclaringClass());
            result.add(e);
            return result;
        }

        public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2) {
            EnumSet<E> result = noneOf(e1.getDeclaringClass());
            result.add(e1);
            result.add(e2);
            return result;
        }

        public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3) {
            EnumSet<E> result = noneOf(e1.getDeclaringClass());
            result.add(e1);
            result.add(e2);
            result.add(e3);
            return result;
        }

    핵심정리
        :인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변인수가 반드시 필요하다.
        메서드를 정의할 때 "필수 매개변수"는 가변인수 앞에 두고, 가변인수를 사용할 때는 "성능 문제"까지 고려하자.

null이 아닌, 빈 컬렉션이나 배열을 반환하라.
    :컬렉션이나 배열 같은 컨테이너가 비었을 때 null 을 반환하는 메서드를 사용하면
    클라이언트는 항상 방어 코드를 넣어줘야 한다.
    :null 을 반환하려면 반환하는 쪽에서도 상황을 특별히 취급해줘야 해서 코드가 더 복잡해진다.

    static class CheeseStock {
        private final List<Cheese> cheesesInStock = ...

        public List<Cheese> getCheeses() {
            return cheesesInStock.isEmpty() ? null :
                new ArrayList<>(cheesesInStock);
        }

    List<Cheese> cheeses = shop.getCheeses();
    if (cheeses != null && cheeses.contains(cheese))
        System.out.println("좋았어, 바로 그거야.");

    :배열을 쓸 때도 절대 null을 반환하지 말고 길이가 0인 배열을 반환하라.
    :성능이 매우 민감하다면 길이 0 짜리 배열을 미리 선언해두고 그 배열을 반환하라.

    public Cheese[] getCheeses() {
        return cheesesInStock.toArray(new Cheese[0]);
    }

    :List.toArray 에 배열을 미리 할당하지 마라. 성능이 떨어진다.
    public Cheese[] getCheeses() {
        return cheesesInStock.toArray(new Cheese[cheesesInStock.size()]);
    }

    핵심 정리.
    null이 아닌, 빈 배열이나 컬렉션을 반환하라.
    null 을 반환하는 API는 사용하기 어렵고 오류 처리 코드도 늘어난다.

옵셔녈 반환은 신중히 하라.
    :자바 8 전에는 특정 조건에서 값을 반환할 수 없을 때는 null 을 반환하거나 예외를 던졌다.
    :예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡처하므로 성능이 좋지 않다.
    :null 을 반환하면 해당 api 을 사용하는 크랄이언트에서는 별도의 null 처리 코드를 추가해야 한다.
    :Optional<T> 는 null 이 아닌 T 타입 참조를 하나 담거나, 아무것도 담지 않을 수 있다.
    :Optional 은 원소를 최대 1개 가질 수 있는 "불변" 컬렉션이다.
    :옵셔녈을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null 을 반환하는 메서드보다 오류 가능성이 적다.

    컬렉션이 비었다면 예외를 던진다 (예외는 스택 추적 캡처때문에 소모 비용이 크다.)
    public static <E extends Comparable<E>> E max(Collection<E> c) {
        if (c.isEmpty())
            throw new IllegalArgumentException("Empty Collection.");

        E result = null;
        for (E e: c)
            if (result == null || e.compareTo(result) > 0)
                result = e;
        return result;
    }

    Optional 을 반환하면 클라이언트는 NullPointException 을 두려워하지 않아도 된다.
    public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
        if (c.isEmpty())
            return Optional.empty();

        E result = null;
        for (E e: c)
            if (result == null || e.compareTo(result) > 0)
                result = e;
        return Optional.of(result);
    }

    많은 Stream 종단 연산은 Optional 을 지원한다.
    public static <E extends Comparable<E>> Optional<E> max(Collection<E> c) {
        return c.stream().max(Comparator.naturalOrder());
    }

    Optional 을 반환하는 메서드는 절대 null 을 반환하지 마라.
        :옵셔널을 도입한 취지를 무시하는 것이다.

    Optional 을 왜 사용해야 되는가?
        :클라이언트에게 반환값이 없을 수도 있음을 알려준다.
        :값이 없다면 클라이언트는 기본값을 설정할 수 있다. Optional.orElse("단어 없음..")
        :기본 설정값 생성 비용이 크다면 Optional.orElseGet(Supplier<T>) 을 이용해 초기 설정 비용을 낮출 수 있다.
        :값이 없다면 원하는 예외를 던질 수 있다. Optional.orElseThrow
        :값이 항상 있다고 확신한다면 곧바로 꺼낼 수 있는 선택지도 있다. Optional.get

    Optional 의 isPresent 의 사용을 삼가라.
        : isPresent 을 쓴 코드 중 상당수는 다른 메서드로 대체할 수 있으며, 그 편이 더 짧고 명확하다.

        Optional<ProcessHandler> parentProcess = ph.parent();
        if (parentProcess.isPresent())
            System.out.println("부모 PID: " + (parentProcess.isPresent() ? String.valueOf(parentProcess.get().pid()) : "N/A"));

        //Optional.isParent 은 다른 메서드로 항상 대체하자.
        System.out.println("부모 PID: " + ph.parent().map(h -> String.valueOf(h.pid())).orElse("N/A"));

        :Stream 을 사용한다면 Optional::isPresent 대신 Optiona.flatMap 을 사용하자. (자바9에서만 적용)

    컬렉션, 스트림, 배열, 옵서녈 같은 컨테이너 타입을 옵셔널로 감싸지 마라.
        :Optional<List<T>> 대신 빈 List<T> 을 반환하라.
        :컨테이너 Optional 은 코드를 더 복잡하게 만든다.

    박싱된 기본 타입을 담은 옵셔널을 반환하지 마라.
        :기본 타입을 사용한다면 OptionalInt, OptionalLong, OptionalDouble 을 사용하라.

    OptionalInt optionalInt = OptionalInt.of(3);
    System.out.println(optionalInt.orElse(-1));

    Optional 을 맵의 값으로 사용하지 마라.
        :맵은 이미 키에 대한 값이 없다는 기능을 가지고 있다.
        :옵셔널을 값으로 가진다면 키가 있지만 값이 없을 수 있다는 경우를 추가하므로 쓸 데 없이 복잡하다.

    옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없다.

    핵심 정리.
        값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야 하는 메서드라면
        옵셔널을 반환해야 할 상황일 수 있다.

공개된 API 요소에는 항상 문서화 주석을 작성하라.
    :주석은 API 을 더 쓸모 있게 만든다.
    :자바에서는 자바독(Javadoc) 이라는 유틸리티가 이 작업을 도와준다.
    :자바독은 소스코드 파일의 주석을 특수한 형태로 기술된 설명을 추려 API 문서로 변환해준다.

    중요한 자바독 태그.
        @literal, @code, @implSpec.

    공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아라.

    메서드용 문서화 주석은 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다.
        :메서드가 어떻게 동작하는지가 아니라 무엇을 하는지 기술하라. (how 가 아닌 what)
        :해당 메서드를 호출하기 위한 전제조건(precondition) 을 모두 나열하라. (throws 태그로 비검사 예외 선언하여 암시적으로 기술하며 @param 태그를 그 조건에 영향받는 이용해 매개변수을 기술)
        :메서드가 성공적으로 수행된 후에 만족해야 하는 사후조건(postcondition) 을 나열한다.
        :부작용도 문서화하라. (부작용 side effect - 명확히 나타나지 않지만 시스템의 상태에 어떠한 변화를 가져오는 행위)
        :모든 매개변수에 @param, 반환 타입이 void 가 아니라면 @return 태그, 모든 예외에 @throws 태그를 달아라.
        :@param 태그와 @return 태그에는 해당 매개변수가 뜻하는 값이나 반환값을 설명하는 명사구를 써라.

    /**
     * Returns <tt>true</tt> if this list contains the specified element.
     * More formally, returns <tt>true</tt> if and only if this list contains
     * at least one element <tt>e</tt> such that
     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.
     *
     * @param o element whose presence in this list is to be tested
     * @return <tt>true</tt> if this list contains the specified element
     * @throws ClassCastException if the type of the specified element
     *         is incompatible with this list
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     * @throws NullPointerException if the specified element is null and this
     *         list does not permit null elements
     * (<a href="Collection.html#optional-restrictions">optional</a>)
     */
    boolean contains(Object o);

    문서화시 HTML 태그를 사용하라.
        :자바독 유틸리티는 문서화 주석을 HTML로 변환해준다.

    /**
     * Returns an array containing all of the elements in this list in
     * proper sequence (from first to last element); the runtime type of
     * the returned array is that of the specified array.  If the list fits
     * in the specified array, it is returned therein.  Otherwise, a new
     * array is allocated with the runtime type of the specified array and
     * the size of this list.
     *
     * <p>If the list fits in the specified array with room to spare (i.e.,
     * the array has more elements than the list), the element in the array
     * immediately following the end of the list is set to <tt>null</tt>.
     * (This is useful in determining the length of the list <i>only</i> if
     * the caller knows that the list does not contain any null elements.)
     *
     * <p>Like the {@link #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * <p>Suppose <tt>x</tt> is a list known to contain only strings.
     * The following code can be used to dump the list into a newly
     * allocated array of <tt>String</tt>:
     *
     * <pre>{@code
     *     String[] y = x.toArray(new String[0]);
     * }</pre>
     *
     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
     * <tt>toArray()</tt>.
     *
     * @param a the array into which the elements of this list are to
     *          be stored, if it is big enough; otherwise, a new array of the
     *          same runtime type is allocated for this purpose.
     * @return an array containing the elements of this list
     * @throws ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in
     *         this list
     * @throws NullPointerException if the specified array is null
     */
    <T> T[] toArray(T[] a);

    자바독 @code 태그.
        :태그로 감싼 내용을 코드용 폰트로 렌더링한다.
        :태그로 감싼 내용에 포함된 HTML 요소나 다른 자바독 태그를 무시한다.
        :HTML 메타문자인 < 기호를 별다른 처리 없이 바로 사용할 수 있다.
        :문서화 주석에 여러 줄로 된 코드 예스를 넣으려면 {@code} 태그를 다시 <pre> 태그로 감싸라.

         * <pre>{@code
         *     String[] y = x.toArray(new String[0]);
         * }</pre>

    자바독 @implSpec 태그.
        :자기사용 패턴(self-use pattern) 에 대해 문서로 남겨 다른 프로그래머가 해당 클래스를
        올바르게 상속 재정의하는 방법을 알려줘야 한다.

    자바독 @literal
        :API 설명에 <, >, & 등의 HTML 메타문자를 사용하려면 {@literal} 을 사용한다.

    요약 설명
        :각 문서화 주석의 첫 번째 문장.
        :요약 설명은 반드시 대상의 기능을 고유하게 기술해야 한다.

    핵심 정리.
        문서화 주석은 api를 문서화하는 가장 훌륭하고 효과적인 방법이다.
        공개 API라면 빠짐없이 설명을 달아야 한다. 표준 규약과 일관된 자바독 태그를 사용하도록 하자.

지역변수의 범위를 최소화하라.
    :지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다.

    가장 처음 쓰일 때 지역변수를 선언하라.
        :지역변수를 미리 선언해두면 코드가 어수선해져 가독성이 떨어진다.
        :변수를 실제로 사용하는 시점에 타입과 초기값이 기억하기 어렵다.

    지역변수는 선언과 동시에 초기화하라.
        :try-catch 문을 제외하고 모든 선언과 초기화를 동시에 하라.
        :초기화에 필요한 정보가 충분하지 않다면 충분할 때까지 선언을 미뤄라.

        for (Element e: elements) {
            .. //to do something
        }

    반복문 while 문 대신 for 혹은 for-each 문을 써라.
        :반복 변수(loop variable)의 볌위가 반복문의 몸체, for 문의 블럭으로 자동 제한된다.
        :while 문은 반복 변수를 블럭 외부에 선언하므로 지역변수의 범위가 for 문의 반복 변수보다 길다.

        for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
            Element e = i.next();
        }

    for 문을 사용시 한계값의 계산 비용이 크다면 반복 변수(loop variable) 과 같이 선언하라.
        for (int i=0, n=c.size(); i<n; i++) {
            System.out.println(c.get(i));
        }

    지역변수의 범위를 최소화하기 위해서 메서드를 작게 유지하고 한 가지 기능에 집중하라.
        :한 메서드가 여러 가지 기능을 처리하면 그만큼 지역변수도 많아진다.
        :반대로 지역변수가 많다면 메서드가 여러 가지 기능을 처리하지 않는지 의심하라.

전통적인 for 문보다는 for each 문을 사용하라.
    :반복자(iterator) 와 반복 변수는 모두 코드를 지저분하게 한다.
    :이처럼 쓰이는 요소 종류가 늘어나면 오류가 생길 가능성이 높아진다.
    :전통적인 for 문은 배열이냐 컬렉션에 따라 코드 형태가 달라진다.

    for-each 문은 반복자와 반복 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 이유가 없다. 또한 컬렉션과 배열을 같은 방식으로 다룰 수 있다.

    for-each 문과 전통적 for 문과 성능 속도는 같다.

    전통 for 문은 중첩 순회를 복잡하게 한다.
        :반복문을 중첩할 때 실수하기 쉽다.

    중첩 순회시 전통 for 문을 사용할 때 자주 발생하는 실수1.
    for (Iterator<Suit> i=suits.iterator(); i.hasNext(); )
        for (Iterator<Rank> j=ranks.iterator(); j.hasNext(); )
            deck.add(Card.of(i.next(), j.next()));  //NoSuchElementException

    중첩 순회시 전통 for 문을 사용할 때 자주 발생하는 실수2.
    for (Iterator<Face> i=faces.iterator(); i.hasNext(); )
        for (Iterator<Face> j=faces.iterator(); i.hasNext(); )
            System.out.println(i.next() + " " + j.next());  //예외조차 발생하지 않으니 문제가 더 심각하다.

    for each 문을 사용하면 가독성과 실수가 줄어든다.
        for (Iterator<Suit> i=suits.iterator(); i.hasNext(); ) {
            Suit suit = i.next();
            for (Iterator<Rank> j=ranks.iterator(); j.hasNext(); )
                deck.add(Card.of(suit, j.next()));
        }

        for (Suit suit: suits)
            for (Rank rank: ranks)
                deck.add(Card.of(suit, rank));

    전통적인 for each 문을 사용할 수 밖에 없는 경우.
        1. 파괴적인 필터링.
            :컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 사용해야 한다.
        2. 변형
            :리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 반복자나 배열의 인덱스를 사용해야 한다.
        3. 병렬 반복.
            :여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

    원소의 묶음을 표현한다면 Iterable 을 구현하라.

    핵심 정리.
        전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해주고 성능 저하도 없다.
        가능한 모든 곳에서 for 문이 아닌 for-each 문을 사용하라.

라이브러리를 익히고 사용하라.
    :표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 이전의 프로그래머들의 경험을 활용할 수 있다.
    :표준 라이브러리를 사용하면 안전하므로 핵심적인 일과 관련 없는 문제에 대해 해결할 필요가 없다.
    :표준 라이브러리의 성능은 지속적으로 개선된다.
    :표준 라이브러리는 꾸준히 기능이 추가된다.
    :표준 라이브러리를 사용한 코드는 다른 개발자도 낯익으므로 가독성이 좋다.

    자바 개발자라면 java.lang, java.util, java.io, java.concurrent 와 그 하위 패키지들을 무조건 익혀라.


공유 중인 가변 데이터는 동기화해 사용해라.
    @synchronized 키워드
        :해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장.
    @동기화의 의의.
        :한 스레드가 변경중인 상태의 가변 객체를 다른 스레드가 보지 못하게 막는 용도.
        :반대로 동기화는 한 스레드가 만든 변화를 다른 스레드에서 보도록 보장.
        :동기화에 접근한 쓰레드는 객체에 락(lock) 을 걸며, 락을 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다.
        :정리하면, 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론,
        동기화된 메서드나 블록에 들어간 스레드가 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

    @동기화를 하지 않았을 때.
        :long과 doulbe 외의 변수를 읽고 쓰는 동작은 원자적이므로, 동기화 없이 수정하는 중이라도, 항상 어떤 쓰레드가 정상적으로 저장한 값을 온전히 읽어올 수 있다.
        위에서 말했듯, 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된 값'을 얻는다고 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.

    @다른 쓰레드를 멈추는 법.
        :대상 쓰레드를 자신의 boolean 필드를 폴링(pooling) 하면서 그 값이 true 가 되면 멈춘다.
        :pooling 하는 블럭을 동기화하지 않으면 메인 스레드가 수정한 값을 백그라운드 스레드가 언제쯤에나 보게 될지 보증할 수 없다.

    공유 중인 가변 데이트는 읽기 & 쓰기 메서드를 모두 동기화하라
        :쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다.
        :동기화를 통해 배타적 수행과 스레드 간 통신을 수행하라.
        :동기화를 하는 방법에는 synchronized 키워드와 필드를 volatile 로 선언하는 방법이 있다.

    ex) backgroundThread 은 다른 쓰레드가 변경한 값을 언제 볼지를 보장하지 못한다.
        public class StopThread {
            private static boolean stopRequested;

            public static void main(String[] args) throws InterruptedException {
                Thread backgroundThread = new Thread(() -> {
                    int i=0;
                    while (!stopRequested)
                        i++;
                });
                backgroundThread.start();
                TimeUnit.SECONDS.sleep(1);
                stopRequested = true;
            }


        public class StopThread {
            private static boolean stopRequested;

            private static synchronized boolean stopRequested() {
                return stopRequested;
            }

            private static synchronized void requestStop() {
                stopRequested = true;
            }

            public static void main(String[] args) throws InterruptedException {
                Thread backgroundThread = new Thread(() -> {
                    int i=0;
                    while (!stopRequested())
                        i++;
                });
                backgroundThread.start();
                TimeUnit.SECONDS.sleep(1);
                requestStop();
            }
        }

        @volatile 한정자
            :항상 최근에 기록된 값 (프로세스 힙에 저장된) 값을 읽게 됨을 보장.
            :하지만 두 쓰레드가 한 필드에 동시에 접근했을 때, 하나의 어떠한 연산중인 해당 필드의 값을 변경하는 중이라면 다른 쓰레드가 변경된 값을 읽음을 보장하지 않는다 (연산이 진행중이라면).
            :예를 들어 nextSerialNumber 증가 연산자로 증가 시킬때, 여러 쓰레드는 nextSerialNumber 필드에 여러번 접근할 수 있으므, 각 쓰레드는 먼저 값을 읽고, 그런 다음 1 증가한 새로운 값을 저장한다.
            만약 어떠한 쓰레드가 이러한 과정을 비집고 들어와 값을 일어가면 첫 번째 스레드와 똑같은 값을 돌려받게 된다.
            :이를 방지하기 위해 동기화시 volatile 로 필드를 선언하지 말고 synchronized 키워드를 사용하라.

        ex) 쓰레드 안전 실패(safety failure)
        private static volatile int nextSerialNumber = 0;

        public static int generateSerialNumber() {
            return nextSerialNumber++;
        }

        for (int i=0; i<1000; i++) {
            new Thread(() -> System.out.println(generateSerialNumber())).start(); //last el - 998
        }

    }

    @안전 실패 (safety failure).
        :쓰레드에 의해 잘못된 결과를 계산해내는 오류.
    @응답 불가 (liveness failure)
        :프로그램이 더이상 진행되지 못하는 상태.

    java.util.concurrent.atomic 패키지.
        :이 패키지는 락 없이도 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있다.

    애초에 가변 데이터를 공유하지 마라.
        :불변 데이터만 공유하고 아무것도 공유하지 마라. 다시 말해 가변 데이터는 단일 스레드에서만 쓰도록 하라.

        @효과적 불변(effectively immutable)
            :객체를 안전하게 발행하기 위해, 클래스 초기화 과정에서 객체를 정적 필드, volatile 필드, final 필드 혹은 보통의 락을 통해 접근 하는 필드에 저장.
            혹은 동시성 컬렉션에 저장한다.

    핵심 정리.
        여러 스레드가 가변 데이터를 ㄱ공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.
        동기화하지 않으면 '한 스레드가 수행한 변경'을 '다른 스레드가 보지 못할 수 있다'.
        공유되는 가변 데이터를 동기화하는데 실패하면 (위의 상황), 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
        배타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 'volatile' 한정자만으로 동기화할 수 있다.

과도한 동기화는 피하라.
    :응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언로 양도하지 마라.

    @동기화 메서드에서의 제어 양도.
        :동기화된 영역 안에서 클라이언트가 재정의한 메서드를 호출하거나, 클라이언트가 넘겨준 함수 객체를 호출.

    @ConcurrentModificationException
        :if the set is modified at any time after the iterator is created, in any way except through the iterator's own <tt>remove</tt> method,
        the Iterator throws a {@link ConcurrentModificationException}.

    ex)
        public class ObservableSet<E> implements Set<E> {
            private final List<SetObserver<E>> observers = new ArrayList<>();
            private Set<E> set;

            public ObservableSet(Set<E> set) {
                this.set = set;
            }

            public void addObserver(SetObserver<E> observer) {
                synchronized (observers) {
                    observers.add(observer);
                }
            }

            public boolean removeObserver(SetObserver<E> observer) {
                synchronized (observers) {
                    return observers.remove(observer);
                }
            }

            private void notifyElementAdded(E element) {
                synchronized (observers) {
                    for (SetObserver<E> observer: observers)
                        observer.added(this, element);
                }
            }

            @Override
            public boolean add(E e) {
                boolean added = set.add(e);
                if (added)
                    notifyElementAdded(e);
                return added;
            }
            ...
        @FunctionalInterface
        interface SetObserver<E> {
            void added(ObservableSet<E> set, E element);
        }

        ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>());
        set.addObserver(new SetObserver<Integer>() {
            @Override
            public void added(ObservableSet<Integer> set, Integer e) {
                System.out.println(e);
                if (e == 23)
                    set.removeObserver(this); //ConcurrentModificationException - 원소를 iterator 로 순회 중에 remove 를 호출했다.
            }
        });
        for (int i=0; i<100; i++)
            set.add(i);

        set.addObserver(new SetObserver<Integer>() {
            @Override
            public void added(ObservableSet<Integer> set, Integer e) {
                System.out.println(e);
                if (e == 23) {
                    ExecutorService exec = Executors.newCachedThreadPool();
                    try {
                        exec.submit(() -> set.removeObserver(this)).get(); //이미 Main thread 가 notifyElementAdded 로 lock 을 쥐고 있으므로 교착 상황에 빠진다.
                    } catch (ExecutionException | InterruptedException ex) {
                        throw new AssertionError(ex);
                    } finally {
                        exec.shutdown();
                    }
                }
            }
        });
        for (int i=0; i<100; i++)
            set.add(i);

    @교착 상태의 주 원인.
        :주로 동기화된 영역 안에서 외계인 메서드(외부의 메서드)를 호출하여 교착 상태에 빠진다.

    제어를 클라이언트에 양도할려거든 동기화 블럭 밖으로 빼내라.
        외계인 메서드를 호출하여 락의 획득을 실패해서 교착 상황에 빠졌을 때는 외계인 메서드를 호출하는 코드를 동기화 코드 밖으로 빼내라.


    private void notifyElementAdded(E element) {
        List<SetObserver<E>> snapshot = null;
        synchronized (observers) {
            snapshot = new ArrayList<>(observers);
        }
        for (SetObserver<E> observer: snapshot)
            observer.added(this, element);
    }

    동기화 영역에서는 가능한 일을 적게 하라.
        :락을 얻고, 공유 데이터를 검사하고, 필요하면 수정하고, 락을 놓는다.

    핵심 정리.
        :교착 상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자.
        또한, 동기화 영역 안에서의 작업을 최소화하자.

스레드보다는 실행자, 태스트, 스트림을 애용하라.
    :java.util.concurrent 은 실행자 프레임워크(Executor Framework) 라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

    백그라운드 스레드를 통한 작업 태스트 큐.
        :Executors.newSingleThreadExecutor 을 통해 뛰어난 백그라운드 작업 큐를 생성할 수 있다.

    작업 큐 생성.
        ExecutorService exec = Executors.newSingleThreadExecutor();
    실행자에 실행할 태스크 전달.
        exec.execute(runnable);
    실행자를 종료.
        exec.shutdown();

    ExecutorService 의 기능.
        :특정 태스크가 완료되기를 기다린다. (get 메서드)
        :태스크 모음 중 아무것도 하나(invokeAny) 혹은 모든 태스크(invokeAll) 가 완료되기를 기다린다.
        :실행자 서비스가 종료하기를 기다린다(awaitTermination 메서드)
        :완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService)
        :태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor)

    Executors의 정적 팩토리.
        :태스크의 큐를 둘 이상의 스레드가 처리하고 싶다면 Executors 의 다른 정적 팩토리를 이용하라.

    @CachedThreadPool
        :Executors.newCachedThreadPool 정적 팩토리로 생성되며, 요청받은 태스크들이 즉시 스레드에 위임돼 실행되며, 가용할 스레드가 없다면 새로 하나 생성된다.
        무거운 프러덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool 을 사용하라.

    쓰레드를 직접 다루지 말고 실행자 프레임워크를 사용해라.
        :쓰레드를 직접 다루면 tHREAD 가 작업 단위와 수행 매커니즘(runnable) 을 모두 수행해야 되지만,
        실행자 프레임워크에서는 작업 단위와 실행 메커니즘(runnable) 이 분리된다.

    @태스크
        자바 쓰레드의 태스크는 Runnable 과 Callable 추상화되있다.
        Callable 은 Runnable 과 비슷하지만 값을 반환하고 예외를 던질 수 있다.
        태스크를 실행하는 매커니즘이 바로 실행자 서비스다.
        실행사 서비스는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다.
        즉 실행자 프레임워크가 작업 수행을 담당해준다.

wait 와 notify 보다는 동시성 유틸리티를 애용하라.
    :wait 과 notify 은 사용하기 아주 까다롭다.
    :java.util.concurrent 의 고수준 유틸리티는 실행자 프레임워크, 동시성 컬렉션(concurrent collection), 동기화 장치(synchronizer) 세 범주로 나눌 수 있다.
    :가장 잘 쓰이는 동기화 장치는 CountDownLatch 와 Semaphore, Phaser 다.

    @CountDownLatch
        :스레드를 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다.
        :CountDownLatch 의 생성자는 int 값을 받으며, 이 값이 래치의 countDown 메서드를 몇번 호출해야 대기 중인 스레드들을 깨우는지 결정한다.
        A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.

지연 초기화는 신중히 사용하라.
    :지연 초기화(lazy initialization) 은 필드의 초기화 시점을 그 값이 처음 필요할때까지 늦추는 기법.
    :지연 초기화는 주로 최적화 용도로 사용된다.

    지연 초기화는 양날의 검이다.
        :인스턴스 생성 시의 초기화 비용은 줄지만 그 대신 지연 초기화하는 필드에 접근하는 비용은 커진다.
    멀티 스레드 환경에선는 지연 초기화가 더 까다롭다.
        :필드를 둘 이상의 스레드가 공유한다면 어떤 형태로든 반드시 동기화해야 한다.


직렬화.
    @직렬화
        :객체를 바이트 스트림을 이용하여 인코딩(직렬화) 하고 다른 바이트 스트림으로부터 다시 객체를 재구성(역직렬화).
        :이렇게 직렬화된 객체는 다른 VM 에 전송하거나, 디스크에 저장한 후 나중에 역직렬화할 수 있다.

자바 직렬화의 대안을 찾아라.
    :직렬화의 근본적 문제는 보안 문제인다.
    :ObjectInputStream 의 readObject 은 Serializable 을 구현한 클래스패스 안의 모든 타입의 객체를 만들어 낼 수 있다.
    :바이트 스트림을 역직렬화하는 과정에서 이 readObject 은 그 타입들 안의 모든 코드를 수행할 수 있다.


    ex) 깊이가 100 단계인 HashSet 인스턴스가 하나의 인스턴스를 역직렬화하려면 그 원소들의 해시코드를 계산해야 한다.
        static byte[] bomb() {
            Set<Object> root = new HashSet<>();
            Set<Object> s1 = root;
            Set<Object> s2 = new HashSet<>();
            for (int i=0; i<100; i++) {
                Set<Object> t1 = new HashSet<>();
                Set<Object> t2 = new HashSet<>();
                t1.add("foo");
                s1.add(t1); s1.add(t2);
                s2.add(t1); s2.add(t2);
                s1 = t1;
                s2 = t2;
            }
            return serialize(root);
        }

    자바 직렬화보단 JSON 을 사용하라.
        :자바 직렬화보다 더 간단하며, 사람이 읽을 수 있다.

    신뢰할 수 없는 데이터는 절대 역직렬화하지 마라.
        :ObjectInputFilter 을 이용하여 필터링하라.

        @ObjectInputFilter
            :클래스 단위로, 특정 클래스를 역직렬화를 거부할 수 있다.

Serializable 을 구현할지는 신중히 결정하라.
    :Serializable 을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
    :직렬화된 바이트 스트림 인코딩이 널리 퍼지므로, 그 직렬화 형태도 영원히 지원해야 한다.

    @기본 직렬화 형태.
        :단지 클래스 선언에 implements Serializable 을 선언한 형태의 직렬화로
        private 과 package-private 인스턴스 필드들이 모두 직렬화되므로 내부 구현 공식을 공개한다. (캡슐화 실패)

    기본 직렬화 형태를 피하라.
        :기본 직렬화 형태를 사용하면 내부 표현을 바꾸기 어렵다.

    @직렬 UID (serial version UID)
        :모든 직렬화된 클래스는 고유 식별 번호를 부여받는다.
        :이 값은 serialVersionUID 라는 이름의 static final long 필드의 값으로,
        이 번호를 명시하지 않으면 시스템이 런타임에 암호 해시 함수(SHA-1) 을 적용해 자동으로 클래스 안에 생성해 넣는다.
        :만약 직렬 버전 UID 가 달라진 클래스을 역질렬화하려 한다면 호환성이 깨져 InvalidClassException 이 발생한다.

    Serializable 구현의 문제는 "불변식"을 해칠 수 있다.
        :직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법으로,
        생성자나 정적 팩토리 메서드에서 정의한 "불변식"을 피해 객체를 생성한다.

    상속용을 설계된 클래스와 인터페이스도 대부분 Seriallizable 을 구현하면 안된다.
        :이 규칙을 따르지 않으면, 그 클래스나 인터페이스를 구현하는 이에게 큰 부담을 지우게 된다.

커스텀 직렬화 형태를 고려하라.
    :기본 직렬화 형태를 사용한다면 다음 릴리스 때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.
    :객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.

    불변식 보장과 보안을 위한 readObject.
        :@serial 태그로 해당 필드에 대한 불변식을 기술하라.
        @serail 태그로 기술한 내용은 API 문서에서 직렬화 형태를 설명하는 특별한 페이지에 기록된다.

    물리적 표현과 논리적 내용이 다른 클래스.
        :논리적(추상적) 으로 아래 클래스는 일련의 문자열을 표현하지만,
        물리적(구현적)으론 문자열들을 이중 연결 리스트로 연결한다.
        :이럴때 기본 직렬화 형태를 사용하면
            1. 내부 표현 방식에 영구히 묶인다.
            2. 너무 많은 공간을 차지한다.
                :내부 정보까지 모두 기록하면, 직렬화 형태가 너무 커져 디스크 저장하거나 네트워크로 전송하는 속도가 느려진다.
            3. 시간이 너무 많이 걸린다.
                :그래프를 직접 순회하므로 느리다.
            4. 스택 오버플로를 일으킬 수 있다.

    public class StringList implements Serializable {
        private int size = 0;
        private Entry head = null;

        private static class Entry implements Serializable {
            String data;
            Entry next;
            Entry previous;
        }
    }

    물리적인 상세 표현을 숨긴체, 논리적 구성만 직렬화하기.
        :writeObject 와 readObject 를 구현하여 직렬화 형태를 처리.

        @transient
            :일시적이란 뜻의 transient 한정자는 해당 필드가 기본 직렬화 형태에 포함되지 않는다는 것을 지정.

        @ObjectOutputStream 과 ObjectInputStream 의 defaultWriteObject, defaultReadObject
            : 클래스가 transient 필드를 가질시 반드시 호출하라.
            : transient 와 static 이 아닌 인스턴스 필드만을 write 한다.
            : 이렇게 하면 transient 가 아닌 인스턴스 필드가 추가되더라도 직렬화를 위해 호환될 수 있다.
            : 반대로 transient 가 아닌 필드는 자동으로 직렬화에 추가되니 조심하자.

        /**
         * Write the non-static and non-transient fields of the current class to
         * this stream.  This may only be called from the writeObject method of the
         * class being serialized. It will throw the NotActiveException if it is
         * called otherwise.
         *
         * @throws  IOException if I/O errors occur while writing to the underlying
         *          <code>OutputStream</code>
         */
        public void defaultWriteObject() throws IOException {
            SerialCallbackContext ctx = curContext;
            if (ctx == null) {
                throw new NotActiveException("not in call to writeObject");
            }
            Object curObj = ctx.getObj();
            ObjectStreamClass curDesc = ctx.getDesc();
            bout.setBlockDataMode(false);
            defaultWriteFields(curObj, curDesc);
            bout.setBlockDataMode(true);
        }

    transient 한정자를 항상 지정하라.
        :defaultWriteObject 메서드를 호출하면 transient 로 선언하지 않은 모든 인스턴스 필드가 직렬화된다.
        :외부에 노출해도 상관없고, 해당 객체의 논리적 상태와 물리적 상태가 일치하는 필드라고 확신할 때만 transient 한정자를 생략하라.

    어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID(serial version UID) 를 명시하자.
        :이렇게 되면 잠재적인 호환성 문제가 사라지고, 성능도 조금 빨라진다.

        private static final long serialVersionUID = <무작위 long 값>;

        :기본 버전 클래스와 호환성을 끊고 싶다면 단순히 직렬 버전 UID 값을 바꿔줘라.
        :이렇게 되면 기존 버전의 인스턴스를 역질렬화할때 InvalidClassException 이 던져진다.
        :반대로 구버전으로 직렬화된 인스턴스들과의 호환성을 끊을려는 경우를 제외하곤 직렬 버전 UID 을 절대 수정하지 마라.

readObject 메서드는 방어적으로 작성하라.
    :직렬화시 객체의 "불변식"을 보장하기 위해선 생성자와 똑같은 수준으로 주의를 기울여야 한다.
    :readObject 메서드에서는 인수가 유효한지 검사해야 한다 (아이템 49).
    :readObject 매개변수를 방어적으로 복사해야 한다 (아이템 50).

    @readObject
        : 직렬화시 사용되며 기능은 매개변수로 바이트 스트림으로 받는 생성자와 같다.
        : readObject 메서드는 defaultReadObject 을 호추랗ㄴ 다음 역질렬화된 객체가 유효한지 검사해야 한다.
        : 유효성 검사에 실패하면 InvalidObjectException 을 던져야 한다.

        @defaultReadObject
            :readObject 에서는 defaultReadObject 을 호출해야만 transient 가 아닌 필드을 바이트에서 읽어온다.
            /**
             * Read the non-static and non-transient fields of the current class from
             * this stream.  This may only be called from the readObject method of the
             * class being deserialized. It will throw the NotActiveException if it is
             * called otherwise.
             *
             * @throws  ClassNotFoundException if the class of a serialized object
             *          could not be found.
             * @throws  IOException if an I/O error occurs.
             * @throws  NotActiveException if the stream is not currently reading
             *          objects.
             */
            public void defaultReadObject()
                throws IOException, ClassNotFoundException
            {
                SerialCallbackContext ctx = curContext;
                if (ctx == null) {
                    throw new NotActiveException("not in call to readObject");
                }
                Object curObj = ctx.getObj();
                ObjectStreamClass curDesc = ctx.getDesc();
                bin.setBlockDataMode(false);
                defaultReadFields(curObj, curDesc); //해당 객체의 필드를 읽어온다.
                bin.setBlockDataMode(true);
                if (!curDesc.hasWriteObjectData()) {
                    defaultDataEnd = true;
                }
                ClassNotFoundException ex = handles.lookupException(passHandle);
                if (ex != null) {
                    throw ex;
                }
            }

        public class Period implements Serializable {
            private final Date start;
            private final Date end;

            /**
             * @param start 시작 시각.
             * @param end 종료 시각; 시작 시간보다 뒤여야 한다. {@code end.compareTo(start) > 0}
             * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
             * @throws NullPointerException start 나 end 가 null이면 발생.
             */
            public Period(Date start, Date end) {
                this.start = new Date(start.getTime());
                this.end = new Date(end.getTime());
                if (start.compareTo(end) > 0)
                    throw new IllegalStateException(start + "가 " + end + " 보다 늦다.");
            }

            public Date getStart() {
                return new Date(start.getTime());
            }

            public Date getEnd() {
                return new Date(end.getTime());
            }

            @Override
            public String toString() {
                return start + " - " + end;
            }
        }

        class BogusPeriod {
            // Byte stream could not have come from real Period instance!
            private static final byte[] serializedForm = new byte[] { (byte) 0xac,
                    (byte) 0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06, 0x50, 0x65, 0x72,
                    0x69, 0x6f, 0x64, 0x40, 0x7e, (byte) 0xf8, 0x2b, 0x4f, 0x46,
                    (byte) 0xc0, (byte) 0xf4, 0x02, 0x00, 0x02, 0x4c, 0x00, 0x03, 0x65,
                    0x6e, 0x64, 0x74, 0x00, 0x10, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f,
                    0x75, 0x74, 0x69, 0x6c, 0x2f, 0x44, 0x61, 0x74, 0x65, 0x3b, 0x4c,
                    0x00, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x71, 0x00, 0x7e, 0x00,
                    0x01, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0e, 0x6a, 0x61, 0x76, 0x61,
                    0x2e, 0x75, 0x74, 0x69, 0x6c, 0x2e, 0x44, 0x61, 0x74, 0x65, 0x68,
                    0x6a, (byte) 0x81, 0x01, 0x4b, 0x59, 0x74, 0x19, 0x03, 0x00, 0x00,
                    0x78, 0x70, 0x77, 0x08, 0x00, 0x00, 0x00, 0x66, (byte) 0xdf, 0x6e,
                    0x1e, 0x00, 0x78, 0x73, 0x71, 0x00, 0x7e, 0x00, 0x03, 0x77, 0x08,
                    0x00, 0x00, 0x00, (byte) 0xd5, 0x17, 0x69, 0x22, 0x00, 0x78 };

            public static void main(String[] args) {
                Period p = deserialize(serializedForm);
                System.out.println(p);  //잘못된 바이트를 직렬화하여 객체의 불변식이 깨진다.
            }

            private static Period deserialize(byte[] sf) {
                try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(sf))) {
                    return (Period) in.readObject();
                } catch (IOException | ClassNotFoundException e) {
                    throw new IllegalStateException(e);
                }
            }
        }

    객체 직렬화 스트림 끝에 추가된 '악의적 객체 참조'를 주의하라.
        :해당 인스턴스를 직렬화한 바이트의 끝에 필드 참조 바이트를 추가하면 가변 인스턴스를 만들 수 있으니 주의해야 한다.
        :객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 반드시 방어적으로 복사하라. (클라이언트에서 전달 받는 혹은 전달하는 객체를 방어적 복사하라)

        public static void main(String[] args) throws IOException, ClassNotFoundException {
            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
                 ObjectOutputStream out = new ObjectOutputStream(baos)) {
                MutablePeriod p = new MutablePeriod(new Date(), new Date());
                out.writeObject(p);
                byte[] ref = { 0x71, 0, 0x7e, 0, 5 }; //#5 start 참조
                baos.write(ref);
                ref[4] = 4; //#4 end 참조
                baos.write(ref);
                try (ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {
                    MutablePeriod p2 = (MutablePeriod) in.readObject();
                    Date s = (Date) in.readObject();
                    Date e = (Date) in.readObject();
                    e.setYear(69);
                    System.out.println(p2);
                }
            }
        }

    핵심 정리.
        :readObject 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임하라.
        :private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라.
        :모든 불변식의 유효성을 검사하여 어긋나면 InvalidObjectException 을 던져라.

직렬화된 인스턴스 대신 직렬화 프록시 사용하라.
    :직렬화를 위해 Serializable 을 구현한 이상 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 됨으로써 버그와 보안 문제 문제가 생길 가능성이 생긴다.
    :직렬화 프록시 패턴(serialization proxy pattern) 을 이용하면 이 위험을 크게 줄일 수 있다.

    @직렬화 프록시 패턴
        :논리적 상태를 표현하는 private static 중첩 클래스(프록시)를 정의.
        :이 클래스의 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사하고 바깥 클래스와 프록시 모두 Serializable 을 구현한다.

        public class ProxyPeriod {
            private final Date start;
            private final Date end;

            public ProxyPeriod(Date start, Date end) {
                this.start = new Date(start.getTime());
                this.end = new Date(end.getTime());
                checkArgument(this.start.compareTo(this.end) <= 0);
            }

            //직렬화 프록시 패턴
            private static class SerializationProxy implements Serializable {
                private static final long serialVersionUID = 1L;
                private final Date start;
                private final Date end;

                public SerializationProxy(ProxyPeriod p) {
                    this.start = p.start;
                    this.end = p.end;
                }

                // writeReplace 으로 직렬화된 프록시를 역직렬화할때 다시 바깥 인스턴스를 생성하여 리턴한다.
                private Object readResolve() {
                    return new ProxyPeriod(start, end);
                }
            }

            // 직렬화 프록시 패턴용 writeReplace 메서드. ProxyPeriod 을 직렬화시 바깥 클래스의 인스턴스 대신 내부 프록시 인스턴스를 반환하게 한다.
            private Object writeReplace() {
                return new SerializationProxy(this);
            }

            private void readObject(ObjectInputStream in) throws InvalidObjectException {
                throw new InvalidObjectException("프록시가 필요합니다.");
            }
        }

    직렬화 프록시 패턴은 해당 클래스의 불변식을 그대로 사용할 수 있고 위험성을 줄인다.
        : readObject 을 사용하지 않으므로 필드를 final "불변식"로 선언할 수 있어 불변식을 충족한다.
        : 역직렬화시 바깥 클래스의 생성자를 그대로 사용하므로 따로 유효성 검사 코드를 작성하지 않아도 된다.

    EnumSet 또한 직렬화 프록시 패턴을 사용했다!
        /**
         * This class is used to serialize all EnumSet instances, regardless of
         * implementation type.  It captures their "logical contents" and they
         * are reconstructed using public static factories.  This is necessary
         * to ensure that the existence of a particular implementation type is
         * an implementation detail.
         *
         * @serial include
         */
        private static class SerializationProxy <E extends Enum<E>>
            implements java.io.Serializable
        {
            /**
             * The element type of this enum set.
             *
             * @serial
             */
            private final Class<E> elementType;

            /**
             * The elements contained in this enum set.
             *
             * @serial
             */
            private final Enum<?>[] elements;

            SerializationProxy(EnumSet<E> set) {
                elementType = set.elementType;
                elements = set.toArray(ZERO_LENGTH_ENUM_ARRAY);
            }

            // instead of cast to E, we should perhaps use elementType.cast()
            // to avoid injection of forged stream, but it will slow the implementation
            @SuppressWarnings("unchecked")
            private Object readResolve() {
                EnumSet<E> result = EnumSet.noneOf(elementType);
                for (Enum<?> e : elements)
                    result.add((E)e);
                return result;
            }

            private static final long serialVersionUID = 362491234563181265L;
        }

        Object writeReplace() {
            return new SerializationProxy<>(this);
        }
