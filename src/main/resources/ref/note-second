
아이템 1. "생성자" 대신 "Static Factory Method" 을 고려하라.
    :Static Factory Method 은 생성자와 별도로 그 클래스의 인스턴스를 생성하여 반환하는 메서드다.
    :Static Factory Method 은 생성자보다 더 좋은 장점 5가지를 가진다.

    /**
     * Returns a {@code Boolean} instance representing the specified
     * {@code boolean} value.  If the specified {@code boolean} value
     * is {@code true}, this method returns {@code Boolean.TRUE};
     * if it is {@code false}, this method returns {@code Boolean.FALSE}.
     * If a new {@code Boolean} instance is not required, this method
     * should generally be used in preference to the constructor
     * {@link #Boolean(boolean)}, as this method is likely to yield
     * significantly better space and time performance.
     *
     * @param  b a boolean value.
     * @return a {@code Boolean} instance representing {@code b}.
     * @since  1.4
     */
    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }

    1. Static Factory Method 은 이름을 가질 수 있다.
        :생성자는 반환될 객체의 특성을 제대로 설명하지 못하지만, Static Factory Method 은 이름만 잘 지으면
        반환될 객체의 특성을 쉽게 설명할 수 있다.

        ex)
            public BigInteger(byte[] val)
            public static BigInteger probablePrime(int bitLength, Random seed)  //가독성이 좋다.

    2. Static Factory Method 은 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        : 불변 클래스(아이템 17) 을 미리 만들어 놓고 캐싱하여 재사용하는 방법을 채용할 수 있다. (Flyweight Pattern: 객체를 가볍게 하기 위한 목적의 패턴)
        : 해당 클래스를 인스턴스 통제(instance-controlled) 클래스로 만들 수 있다.

        @ToString
        static class Coffee {
            private static final Coffee BLACK = new Coffee("BLACK");
            private final String name;

            private Coffee(String name) {
                this.name = name;
            }

            /**
             * @param name of coffee
             * @throws IllegalArgumentException if name is null
             * @throws IllegalArgumentException if name is empty string
             * @return
             */
            private static Coffee of(String name) {
                checkArgument(Objects.nonNull(name) && !name.isEmpty());
                if ("BLACK".equals(name))
                    return BLACK;
                return new Coffee(name);
            }
        }

        @인스턴스 통제 클래스(instance-controlled) 클래스
            :본인 클래스의 인스턴스를 언제 파괴, 생성할지를 통제하는 클래스.
            :instance-controlled 클래스의 예로는 싱글턴(singleton) 혹은 "불변 값 클래스 (a == b 일때만 a.equal(b) 가 성립)", 열거 타입이 있다.

    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        :해당 구현 클래스(자식 객체)를 공개하지 않고도 부모 클래스에서 자식 객체를 반환하도록 반환할 수 있다.
        :이는 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 "인터페이스 기반 프레임워크"에서 자주 사용된다 (Collections).
            :Collections 은 Collection 읜 동반 클래스로 Collection 의 정적 팩터리 메서드의 모음을 정의했다.
        :특정 인터페이스를 구현한 동반 클래스를 private 내부 클래스로 만든 이후 정적 팩토리 메서드로 반환하면
        "개념의 수" 가 줄어들어 클라이언트가 사용하기 편하다.
        :클라이언트는 "인터페이스" 만으로 다루므로 해당 클래스를 다루는 난이도가 낮춰진다.
        :예로는 Collections 의 45 개 Collection 구현체가 있으며 그에 대한 정적 팩토리 메서드를 가진다.

        ex)
        static class Collections {

            public static <E> Collection<E> unmodifiableCollection(Collection<? extends E> c) {
                return new UnmodifiableCollection<>(c);
            }

            private static class UnmodifiableCollection<E> implements Collection<E> {
                private final Collection<? extends E> el;

                public UnmodifiableCollection(Collection<? extends E> el) {
                    checkArgument(el != null);
                    this.el = el;
                }

                @Override
                public E get(int index) {
                    return el.get(index);
                }

                @Override
                public void set(int index, E el) {
                    throw new UnsupportedOperationException();
                }
            }
        }

    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        :3번의 기능을 더 추가한 예로써, 매개변수의 따라 서브 클래스의 "구현체" 를 판단한다. (EnumSet 의 RegularEnumSet 과 JumboEnumSet)
        :인터페이스를 리턴하므로 클라이언트는 인터페이스에 기반에 따라 프로그래밍한다. 따라서 구현체를 다음 릴리즈에서
        교체하더라도 문제가 없다. (인터페이스 프로그래밍하라)

    ex)
        /**
         * Creates an empty enum set with the specified element type.
         *
         * @param <E> The class of the elements in the set
         * @param elementType the class object of the element type for this enum
         *     set
         * @return An empty enum set of the specified type.
         * @throws NullPointerException if <tt>elementType</tt> is null
         */
        public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
            Enum<?>[] universe = getUniverse(elementType);
            if (universe == null)
                throw new ClassCastException(elementType + " not an enum");
            if (universe.length <= 64)  // Enum 의 갯수에 따라 구현체를 선택한다.
                return new RegularEnumSet<>(elementType, universe);
            else
                return new JumboEnumSet<>(elementType, universe);
        }

    5. 정적 팩터리 메서드를 작정하는 시점에는 반환할 객체의 클래스는 존재하지 않아도 된다.
        :이는 서비스 제공자 프레임워크 (service provider framework) 을 근간이 된다.
        :서비스 제공자 프레임워크는 Service Interface, Provider Registration, Service Access 3가지 핵심 컴포넌트로 이뤄진다.

    ex)
        //Service interface
        static interface Connection {

        }

        //Factory class for Service interface
        static interface Driver {
            Connection getConnection();
        }

        //Class for register and service access.
        static class DriverManager {
            private static final List<Driver> registerDrivers = new CopyOnWriteArrayList<>();

            private DriverManager() { }

            public static synchronized void registerDriver(Driver driver) {
                checkArgument(Objects.nonNull(driver));
                if (!registerDrivers.contains(driver))
                    registerDrivers.add(driver);
            }

            //Static factory method for Service Implementation
            public static Connection getConnection(String url)  {
                for (Driver d: registerDrivers) {
                    Connection con = Objects.requireNonNull(d.getConnection());
                    return con;
                }
                throw new IllegalStateException();
            }
        }

    아이템 1 핵심 정리.
        "Static Factory Method" 은 대부분 생성자보다 유리한 경우가 더 많으므로 이를 구현함을 항상 고려하자.

아이템 2. 생성자에 선택적 매개변수가 많다면 빌더를 고려하라.
    : 생성자와 Static Factory Method 은 "선택적 매개변수"가 많을 때 적절히 대응하기 힘들다.

    @점층적 생성자 패턴(telescoping constructor pattern)
        : 생성자의 매개변수를 늘려가는 형태로 하위 생성자는 최상위 생성자를 호출할때까지 위임한다.
        : 점층적이므로 때로는 선택적 매개변수를 필수로 지정할 수 밖에 없는 상황이 있다.
        : 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려우며 버그가 발생한다.

    ex)
    public class NutritionFacts {
        private final int servingSize;       //required
        private final int servings;           //required
        private final OptionalInt calories;
        private final OptionalInt fat;
        private final OptionalInt sodium;
        private final OptionalInt carbohydrate;

        public NutritionFacts(int servingSize, int servings) {
            this(servingSize, servings, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories) {
            this(servingSize, servings, calories, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat) {
            this(servingSize, servings, calories, fat, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
            this(servingSize, servings, calories, fat, sodium, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
            this.servingSize = servingSize;
            this.servings = servings;
            this.calories = calories == 0 ? OptionalInt.empty() : OptionalInt.of(calories);
            this.fat = fat == 0 ? OptionalInt.empty() : OptionalInt.of(fat);
            this.sodium =  sodium == 0 ? OptionalInt.empty() : OptionalInt.of(sodium);
            this.carbohydrate = carbohydrate == 0 ? OptionalInt.empty() : OptionalInt.of(carbohydrate);
        }

        public static void main(String[] args) {
            NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); // 점층적 생성자로는 Optional 값을 대체할 방법이 없다.
        }
    }

    @자바빈즈 패턴.
        :자바빈즈 패턴은 인스턴스를 만들기 쉽고, 더 읽기 쉬운 코드를 만들어준다.
        :자바빈즈는 객체가 만드는 과정(연속적 setter 호출) 동안 일관성(consistency) 가 무너진 상태에 놓인다.
        :"여러 매개변수"에 대한 유효장치를 설정할 수 없다.
        :자바빈즈 패턴은 클래스를 "불변"으로 만들 수 없으며 스레드 안정성을 얻기 어렵다.

    ex)
    public class NutritionFacts {
        private int servingSize = -1;       //required
        private int servings = -1;           //required
        private OptionalInt calories = OptionalInt.empty();
        private OptionalInt fat = OptionalInt.empty();
        private OptionalInt sodium = OptionalInt.empty();
        private OptionalInt carbohydrate = OptionalInt.empty();

        public NutritionFacts() { }

        public void setServingSize(int servingSize) {
            this.servingSize = servingSize;
        }

        public void setServings(int servings) {
            this.servings = servings;
        }

        public void setCalories(int calories) {
            this.calories = OptionalInt.of(calories);
        }

        public void setFat(int fat) {
            this.fat = OptionalInt.of(fat);
        }

        public void setSodium(int sodium) {
            this.sodium = OptionalInt.of(sodium);
        }

        public void setCarbohydrate(int carbohydrate) {
            this.carbohydrate = OptionalInt.of(carbohydrate);
        }

        public static void main(String[] args) {
            //NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);
            NutritionFacts cocaCola = new NutritionFacts();
            cocaCola.setServingSize(240);
            cocaCola.setServingSize(8);
            cocaCola.setCalories(100);
            cocaCola.setSodium(35);
            cocaCola.setCarbohydrate(27);

    빌더 패턴.
        :점층적 생성자 패턴의 안정성과 자바빈즈 패턴의 가독성을 겸비한 패턴.
        :클라이언트는 직접 객체를 생성하는 대신 (생성자를 통해), 세터 메서드들을 제공하는 빌더 객체를 통해 필요한 "불변" 객체를 얻는다.
        :세터 메서드 이후 빌더 자신을 리턴함을 메서드 연쇄(method chaining) 혹은 플루언트 api (fluent api) 라 부른다.
        :build 메서드가 호출하는 생성자에 "불벽식" 을 보장하는 유효 검사를 넣을 수 있다. (아이템 50 - 방어적 복사본을 만든 이후, 이 복사본으로 유효성을 검사하라. - 다른 쓰레드가 복사본을 수성할 시 "불변식"이 다시 깨질 수 있다.)

        @불변식
            : 불변식(invariant) 은 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야 하는 조건을 말한다.
            : 예를들어 Period 클래스에서 start 필드의 값은 반드시 end 필드의 값보다 앞서야 하므로, 두 값이 역전되면 "불변식" 이 깨졌다고 한다.
            : 불변을 가장 "엄격한" 불변식의 예라고 볼 수 있다.

    ex)
    public class NutritionFacts {
        private final int servingSize;       //required
        private final int servings;           //required
        private final OptionalInt calories;
        private final OptionalInt fat;
        private final OptionalInt sodium;
        private final OptionalInt carbohydrate;

        private NutritionFacts(Builder b) {
            this.servingSize = b.servingSize;
            this.servings = b.servings;
            this.calories = b.calories;
            this.fat = b.fat;
            this.sodium = b.sodium;
            this.carbohydrate = b.carbohydrate;
        }

        public static class Builder {
            private final int servingSize;
            private final int servings;
            private OptionalInt calories = OptionalInt.empty();
            private OptionalInt fat = OptionalInt.empty();
            private OptionalInt sodium = OptionalInt.empty();
            private OptionalInt carbohydrate = OptionalInt.empty();

            public Builder(int servingSize, int servings) {
                this.servingSize = servingSize;
                this.servings = servings;
            }

            public Builder calories(int val) { calories = OptionalInt.of(val); return this; }
            public Builder fat(int val) { fat = OptionalInt.of(val); return this; }
            public Builder sodium(int val) { sodium = OptionalInt.of(val); return this; }
            public Builder carbohydrate(int val) { carbohydrate = OptionalInt.of(val); return this; }

            public NutritionFacts build() {
                return new NutritionFacts(this);
            }
        }

    빌더 패턴은 계층적 설계된 클래스와 조합이 좋다.
        :추상 클래스는 추상 빌더를, 구체 클래스는 구체 빌더를 따로 구현한다.
        :이때 하위 클래스에서는 형변환 하지 않고 메서드 연쇄를 위해 셀프 타입 관용구(simulated self-type) 를 사용한다.
        :셀프 타입 관용구시 사용되는 제네릭 타입은 "재귀적 타입 한정" 을 사용한다.

        @공변 반환 타이핑(covariant return typing)
            : 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 것을 의미.

    ex)
    public abstract class Pizza {
        public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
        final Set<Topping> toppings;

        public Pizza(Builder<?> b) {
            this.toppings = b.toppings.clone(); //raw 타입을 사용하지 마라, 방어적 복사를 하라.
        }

        public abstract static class Builder<T extends Builder<T>> {    //Type Safe 한 Generic Container 매개변수를 사용하라, (T 을 Builder 을 상속한 클래스만 한정하는 재귀적 타입 한정 제네릭 타입)
            private EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

            public T addTopping(Topping topping) {
                toppings.add(Objects.requireNonNull(topping));
                return self();
            }

            abstract Pizza build();

            /**
             * @implSpec
             * 하위 클래스는 이 메서드를 재정의하여 this 을 반환하도록 해야 한다.
             * @return
             */
            abstract T self();
        }
    }

    class NyPizza extends Pizza {
        public enum Size { SMALL, MEDIUM, LARGE }
        private final Size size;

        public static class Builder extends Pizza.Builder<Builder> {
            private final Size size;

            public Builder(Size size) {
                this.size = Objects.requireNonNull(size);
            }

            @Override
            Pizza build() {
                return new NyPizza(this);
            }

            @Override
            Builder self() {
                return this;
            }
        }

        public NyPizza(Builder b) {
            super(b);
            this.size = b.size;
        }
    }

    class Calzone extends Pizza {
        private final boolean sauceInside;

        public static class Builder extends Pizza.Builder<Builder> {
            private boolean sauceInside = false;

            public Builder sauceInside() {
                this.sauceInside = true;
                return this;
            }

            @Override
            Pizza build() {
                return new Calzone(this);
            }

            @Override
            Builder self() {
                return this;
            }
        }

        public Calzone(Builder b) {
            super(b);
            this.sauceInside = b.sauceInside;
        }
    }

    아이템 2 핵심 정리.
        생성자나 정적 팩터리가 처리해야 할 (선택적) 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
        빌더는 점층적 생성자보다 가독성이 좋고, 자바빈즈 보다 훨씬 안전하다.

아이템 3. "private 생성자"나 "열거 타입"으로 싱글턴임을 보증하라.
    @Singleton
        :Singleton 이란 "인스턴스가 하나만 존재"하는 클래스를 뜻한다.
        :Singleton 의 전형적인 예로는 Stateless 객체나 설계상 유일해야 하는 '시스템 컴포넌트'을 들 수 있다.
        :Singleton 은 mock 으로 대체할 수 없어 테스트하기 어렵다.

    Singleton 을 생성하는 두 가지 방법.
        public static 멤버 Singleton.
            : static final 멤버는 초기화할 때 딱 한 번만 호출되므로 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.
            : AccessibleObject.setAccessible 을 이용하여 private 메서드를 호출할 수 있으므로 두 번째 객체가 생성될 때 예외를 던질 수 있다..
        ex)
            public class Elvis {
                public static final Elvis INSTANCE = new Elvis();
                private Elvis() { }

                public void leaveTheBuilding() {
                    ..
                }
            }

        Constructor<?>[] c = Elvis.class.getDeclaredConstructors();
        for (Constructor e: c) {
            e.setAccessible(true);
            Elvis elvis = (Elvis) e.newInstance();
            System.out.println(elvis == Elvis.INSTANCE); //two instance by reflection
        }

        Static factory Method 을 이용한 Singleton
            : 이후에 마음이 바뀌면 싱글턴이 아니게 변경할 수 있으므로 멤버 싱글턴보다 유연하다.
            : 혹은 쓰레드별로 다른 인스턴스를 넘겨줄 수 있다. (인스턴스 통제 클래스: 아이템1)
            : 정적 팩토리를 제네릭 싱글톤 팩토리로 만들 수 있다. (이왕이면 제네릭 메서드로 만들라: 아이템30)
            : Static Factory Method 의 메서드 참조를 이용하여 공급자(Supplier) 로 활용할 수 있다.
            ex)
                Supplier<Elvis> supplier = Elvis::getInstance;
                Elvis elvis = supplier.get();

        ex)
            public class Elvis {
                private static int numOfInstance = 0;       //don't set '0'
                private static final Elvis INSTANCE = new Elvis();

                private Elvis() {
                    numOfInstance++;
                    if (numOfInstance > 1)
                        throw new IllegalStateException();
                }

                public static Elvis getInstance() { return INSTANCE; }

                public void leaveTheBuilding() {
                    ..
                }

    Singleton 클래스 대신 Enum 을 사용하라.
        : Enum 은 더 간결하고, 추가 노력 없이 직렬화할 수 있고, 리플렉션 공격에서도 안전하다.
        : 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

   ex)
        enum Singleton {
            INSTANCE;
            Singleton() { }

            public void leaveTheBuilding() {
                System.out.println("Enum over Singleton class");
            }
        }

        Constructor<?>[] c = Singleton.class.getConstructors();
        for (Constructor e: c) { //Constructor[0]
            e.setAccessible(true);
            Singleton singleton = (Singleton) e.newInstance();
            System.out.println(singleton == Singleton.INSTANCE);
        }

아이템 4. 인스턴스화를 막으려거든 "private 생성자"를 사용하라.
    : 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니므로 "인스턴스화를 방지"해야 한다.
    : 추상 클래스로 만드는 것은 인스턴스화를 막을 수 없으므로, private 생성자를 추가하라.

    @유틸리티 클래스.
        :"정적 메서드와 정적 필드를 담은 클래스"
        :"기본 타입 값이나 배열에 관련된 메서드"들을 위해 만든 클래스 혹은
        동적 인터페이스를 구현하는 객체를 생성해주는 "Static Factory Method 을 모아놓은 클래스",
        "final 클래스와 관련한 메서드"들을 정의할 때외에는 유틸리티 클래스를 구현하지 말자.

    인스턴스화를 방지하기 위해 "private 생성자"에 예외를 던져라.
        :reflection 을 통한 인스턴스화를 막을 수 있다.

    ex)
        public class UtilityClass {

        // Suppresses default constructor, ensuring non-instantiability.
        // 인스턴스화를 방지한다 주석을 달자.
        private UtilityClass() {
            throw new AssertionError();
        }

        Constructor<?> c = UtilityClass.class.getDeclaredConstructors()[0];
        c.setAccessible(true);
        UtilityClass instance = (UtilityClass) c.newInstance();

    아이템 4 핵심 정리.
        유틸리티 클래스는 꼭 필요할시에만 구현하자.
        유틸리티 클래스의 인스턴스화를 방지하기 위해선 private 생성자를 구현하고 예외를 던지도록 하자.

아이템 5. 의존하는 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.
    :대부분의 클래스는 하나 이상의 자원에 의존한다. 이때 자원을 해당 클래스에 직접 명시한다면 유연성이 떨어진다.

    //정적 유틸리티를 잘못 사용한 예. (유틸리티 클래스 사용을 자제하라!)
    public class SpellChecker {
        private static final Lexicon dictionary = new Lexicon(); //컴파일 타임에 "특정 하나의 의존성에" 고정된다.

        private SpellChecker() {
            throw new AssertionError();
        }

        public static boolean isValid(String word) {
            return dictionary.hasWord(word);
        }

        public static List<String> suggestions(String typo) {
            return dictionary.getSuggestions(typo);
        }
    }

    의존 객체 주입과 유연성.
        :인스턴스를 생성할 때 "생성자에 필요한 자원을 넘겨받는 형식"을 의존 객체 주입 이라 한다.
        :자원을 직접 명시하면 하나의 자원만 사용 가능하지만 "의존 객체 주입"을 이용해 자원을 사용하면 "사용하는 자원에 따라 동작이 달라져 유연성"이 높아진다.
        :의존 객체 주입을 통해 자원을 공급 받으면 테스트 용이성을 높여준다. (테스트용 의존성을 주입할 수 있다.)
        :의존 객체 주입은 생성자, Static Factory Method, Builder 패턴에 모두 응용 가능하다.

    ex) 의존 객체 주입은 유연성과 테스트 용이성을 높여준다.
        public class SpellChecker {
            private Lexicon dictionary;

            public SpellChecker(Lexicon dictionary) {
                this.dictionary = Objects.requireNonNull(dictionary);
            }

            public boolean isValid(String word) {
                return dictionary.hasWord(word);
            }

            public List<String> suggestions(String typo) {
                return dictionary.getSuggestions(typo);
            }

            Lexicon mock = Mockito.mock(Lexicon.class);
            SpellChecker spellChecker = new SpellChecker(mock);
            spellChecker.isValid("hi");

    의존 객체 주입과 자원 팩토리 제공.
        :한정적 와일드카드 타입을 가진 "Supplier<T extends [Class]> 함수형 인터페이스"를 사용하여 SRP 의 원칙을 따라라.
        :"의존 객체 주입"에 자원 팩토리를 제공하면 "의존 객체의 인스턴스화하는 코드"를 의존 객체로 부터 분리할 수 있다.
    ex)
        public class Mosaic {
            private final Tile tile;

            private Mosaic(Tile tile) {
                this.tile = tile;
            }

            public static <T extends Tile> Mosaic of(Supplier<T> tileFactory) {
                Tile tile = Objects.requireNonNull(tileFactory.get());
                return new Mosaic(tile);
            }
        }

    아이템 5 핵심 정리.
        클래스가 내부적으로 하나 이상의 자원에 의존한다면 싱글턴 혹은 정적 유틸리티 클래스를 사용하지 마라.
        자원들을 클래스 직접 만들게 (직접 명시) 해서도 안된다.
        의존 자원이 필요하다면 생성자에 넘겨주어 (의존 주입) 클래스의 유연성, 재사용성, 테스트 용이성을 높여라.

아이템 6. 불필요한 객체 생성을 피하라.
    :똑같은 기능의 객체를 매번 생성하기보다 재사용하라.
    :'불변 객체'는 언제든 재사용 가능하며 재상용을 한다면 빠르다.

    @JVM의 String 스택.
        :JVM 은 ""로 사용되는 문자열을 재사용한다.
        :new 연산자로 생성된 문자열은 JVM 에 의해 재사용되지 않고 새로 생성되므로 절대 String 생성자를 사용하지 말자.

        /**
         * Initializes a newly created {@code String} object so that it represents
         * the same sequence of characters as the argument; in other words, the
         * newly created string is a copy of the argument string. Unless an
         * explicit copy of {@code original} is needed, use of this constructor is
         * unnecessary since Strings are immutable.
         *
         * @param  original
         *         A {@code String}
         */
        public String(String original) {
            this.value = original.value;
            this.hash = original.hash;
        }

        ex)
            String s = new String(".."); //절대 하지 말 것.

    ex) 불변 객체를 재사용하면 빠르다. (공간 복잡도 뿐만 아니라 시간 복잡도도 매우 증가한다.)
        :"" 으로 사용된 문자열은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 코드가 "같은 객체" 를 재사용함을 보장하므로 초기화 과정이 제외되 빠르다 가볍다.
        :Boolean.valueOf(String) 은 새로운 객체를 생성하는 대신 정적 팩토리를 이용하여 미리 생성된 객체를 반환하므로 빠르다. (아이템 1. 정적 팩토리 메서드를 사용하라)

        Stopwatch stopwatch = Stopwatch.createStarted();
        for (int i=0; i<Integer.MAX_VALUE; i++) {
            String s = new String("bikini");    //69.38ms
        }
        System.out.println(stopwatch.stop());
        stopwatch = Stopwatch.createStarted();
        for (int i=0; i<Integer.MAX_VALUE; i++) {
            String s = "bikini";                //2.076ms
        }
        System.out.println(stopwatch.stop());

    생성 비용이 비싼 객체는 되도록 재사용하라.
        :생성 비용이 "비싼 객체"가 반복해서 필요하다면 "캐싱" 하여서 재사용하라.

    ex) 비싼 객체인 Pattern 인스턴스가 메서드 호출마다 생성되고 버려진다.
        class RomanNumerals {
            private final String roman;
            public RomanNumerals(String roman) {
                checkArgument(roman != null && isRomanNumeral(roman));
                this.roman = roman;
            }

            private boolean isRomanNumeral(String s) {
                return s.matches("(^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$)");    //String.match 은 내부적으로 Pattern 인스턴스를 매번 생성한다.
            }
        }

    ex) 값비싼 Pattern 인스턴스를 재사용해 성능을 높인다.

        class RomanNumerals {
            private final String roman;
            private static final Pattern ROMAN = Pattern.compile("(^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$)");
            private static final Map<String, ReusedRomanNumerals> cache = new ConcurrentHashMap<>();

            public ReusedRomanNumerals(String roman) {
                checkArgument(roman != null && ROMAN.matcher(roman).matches());
                this.roman = roman;
            }

            public static ReusedRomanNumerals of(String roman) {
                if (cache.containsKey(roman))
                    return cache.get(roman);
                checkArgument(roman != null && ROMAN.matcher(roman).matches());
                ReusedRomanNumerals n = new ReusedRomanNumerals(roman);
                cache.computeIfAbsent(roman, k -> n);
                return n;
            }

            stopwatch = Stopwatch.createStarted();
            stopwatch = Stopwatch.createStarted();
            for (int i=0; i<5000000; i++) {
                RomanNumerals rn = new RomanNumerals("XL"); //6.562s 비싼 객체 매번 생성시
            }
            System.out.println(stopwatch.stop());

            stopwatch = Stopwatch.createStarted();
            for (int i=0; i<5000000; i++) {
                ReusedRomanNumerals rn = new ReusedRomanNumerals("XL"); //0.008 s 비싼 의존 객체 캐싱화
            }
            System.out.println(stopwatch.stop());


            stopwatch = Stopwatch.createStarted();
            for (int i=0; i<5000000; i++) {
                ReusedRomanNumerals rn = ReusedRomanNumerals.of("XL"); //0.0008 s 인스통제 클래스를 통한 캐싱화
            }
            System.out.println(stopwatch.stop());

    객체를 불변으로 만들어 재사용하자.
        :불변이라면 재사용해도 항상 안전하다.

    Map의 keySet 과 어댑터 패턴.
        @어댑터 패턴.
            : 3자 클라이언트와의 호환성을 위한 인터페이스을 정의한 클래스로 실제 작업은 뒷단 객체에 위임한다.
            : 어댑터는 뷰 (View) 라고 부르기도 한다.

        Map 은 keySet(View) 을 위해 어댑터 패턴을 이용하며, 이때 내부 자료 구조를 재사용한다.
        ex)
            /**
             * {@inheritDoc}
             *
             * @implSpec
             * This implementation returns a set that subclasses {@link AbstractSet}.
             * The subclass's iterator method returns a "wrapper object" over this
             * map's <tt>entrySet()</tt> iterator.  The <tt>size</tt> method
             * delegates to this map's <tt>size</tt> method and the
             * <tt>contains</tt> method delegates to this map's
             * <tt>containsKey</tt> method.
             *
             * <p>The set is created the first time this method is called,
             * and returned in response to all subsequent calls.  No synchronization
             * is performed, so there is a slight chance that multiple calls to this
             * method will not all return the same set.
             */
            public Set<K> keySet() {
                Set<K> ks = keySet;
                if (ks == null) { // 만약 초기화가 안되었다면 keySet 을 초기화 한다. (지연 초기화)
                    ks = new AbstractSet<K>() {
                        public Iterator<K> iterator() {
                            return new Iterator<K>() {
                                private Iterator<Entry<K,V>> i = entrySet().iterator();

                                public boolean hasNext() {
                                    return i.hasNext();
                                }

                                public K next() {
                                    return i.next().getKey();
                                }

                                public void remove() {
                                    i.remove();
                                }
                            };
                        }

                        public int size() {
                            return AbstractMap.this.size();
                        }

                        public boolean isEmpty() {
                            return AbstractMap.this.isEmpty();
                        }

                        public void clear() {
                            AbstractMap.this.clear();
                        }

                        public boolean contains(Object k) {
                            return AbstractMap.this.containsKey(k);
                        }
                    };
                    keySet = ks;
                }
                return ks;
            }

    오토박싱을 잘못 사용하면 불필요한 객체가 생성된다.
        : 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완벽하지 않다.
        : 박싱된 기본 타입보다는 "기본 타입" 을 사용하고, 의도치 않은 "박싱 객체가 생성되지 않도록 주의"하자.

    ex) 오토 박싱때문에 수많은 객체가 생성된다.
        stopwatch = Stopwatch.createStarted();
        Long sum = 0L;
        for (int i=0; i<Integer.MAX_VALUE; i++) {
            sum += i;                               // 수 많은 i 가 boxing 되고 있다.
        }
        System.out.println(stopwatch.stop());       // 6 s

        stopwatch = Stopwatch.createStarted();
        long sum2 = 0L;
        for (int i=0; i<Integer.MAX_VALUE; i++) {
            sum2 += i;
        }
        System.out.println(stopwatch.stop());       //0.7 s


    아이템 6 핵심 정리.
        똑같은 기능을 하는 객체를 매번 생성하지 말고 재사용 하자.
        생성 비용이 비싼 객체는 더더욱 재사용하자.
        불변 객체는 재사용하기 안전하다.
        어댑터를 통해 객체를 재사용하자.
        하지만 이는 언제나 "똑같은 기능" 과 "불변식"을 지킨다는 한에서다.
        방어적 복사를 해야하는 시점 ("클라이언트가 전달한 객체가 가변이라 해당 객체에 영향이 갈때") 와 객체를 재사용해야 하는 시점을 잘 구별하자.
            => 방어적 복사를 통해 클래스를 불변으로 만들고, 해당 클래스를 재사용하자.

아이템 7. 다 쓴 객체 참조를 해제하라.
    :자바는 가비지 컬렉터가 다 쓴 객체를 알아서 회수해간다.
    :하지만 "메모리 누수의 발생"은 가능하다.

    가비지 컬렉터라도 결국 '다 쓴 참조'를 회수하지 못한다.
        :다 쓴 참조(obsolete reference) 란 앞으로 다시 쓰지 않을 참조를 뜻한다.
        :다 쓴 참조는 가비지 컬렉터가 회수하지 못하므로 결국 OutOfMemoryError 예외가 던져질 수 있다.
        :메모리 누수는 디버깅 하기가 아주 까다롭다.

    ex) 객체를 계속 참조하므로 메모리 누수가 일어난다.
        public class Stack<E> {
            private E[] elements;
            private int size;
            public static final int DEFAULT_INITIAL_CAPACITY = 16;

            @SuppressWarnings("unchecked")
            public Stack() {
                this.elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
            }

            public void push(E e) {
                ensureCapacity();
                elements[size++] = e;
            }

            public E pop() {
                if (size == 0)
                    throw new EmptyStackException();
                return elements[--size];
            }

            /**
             * 원소를 위한 공간을 최소 하나를 확보한다. {@code size == 0 ? 1 : 2 * size + 1}
             * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
             */
            private void ensureCapacity() {
                if (size == elements.length)
                    elements = Arrays.copyOf(elements, (size << 1) + 1);
            }

            public static void main(String[] args) {
                System.out.println(128 << 1);
                System.out.println(50 << 1);
                System.out.println(9 << 1);
            }
        }

    가비지 컬렉터는 '객체 참조 하나만 회수하지 못하는 것이 아니다'.
        :가비지 컬렉터가 특정 객체 참조를 회수하지 못한다면 그 객체 뿐 아니라, 객체가 참조하는 모든 객체를 회수하지 못한다.

    다 쓴 참조(obsolete reference) 은 null 처리하라.
        :다 쓴 참조를 null 처리하면 메모리 누수를 피할 수 있을 뿐 아니라 이미 다쓴 객체를 다시 사용하려면 NullPointException 이 일어난다. (분명 잘못된 일을 수행하였을 것이므로)

        public E pop() {
            if (size == 0)
                throw new EmptyStackException();
            E e = elements[--size];
            elements[size] = null; //obsolete reference 의 null 처리
            return e;
        }

    null 처리는 자기 메모리를 직접 관리할 때만 사용해라.
        :null 처리는 자기 메모리를 직접 관리할 때만 사용해라.
        :보통은 null 처리 대신 (아이템 57. 지역변수의 범위를 최소화하라).
        :자기 메모리를 직접 관리하는 클래스 혹은 캐시를 사용하는 클래스라면 메모리 누수를 항상 주의해라.
        :WeakHashMap 클래스, LinkedHashMap.removeEldestEntry 와 ScheduledThreadPoolExecutor 로 자기 메모리를 관리하는 클래스는 엔트리 청소를 해주어라.
        :WeakReference 로 저장하면 가비지 컬렉터는 즉시 수거해간다.

    @WeakHashMap
        :키의 참조가 살아있는 Map 에 존재하더라도 외부에서 키의 참조가 없다면 해당 Key 은 GC에 의해 메모리가 회수된다.
        :캐쉬 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황에서 사용하며 메모리 누수를 방지한다.

        /**
         * Hash table based implementation of the <tt>Map</tt> interface, with
         * <em>weak keys</em>.
         * An entry in a <tt>WeakHashMap</tt> will automatically be removed when
         * its key is no longer in ordinary use.  More precisely, the presence of a
         * mapping for a given key will not prevent the key from being discarded by the
         * garbage collector, that is, made finalizable, finalized, and then reclaimed.
         * When a key has been discarded its entry is effectively removed from the map,
         * so this class behaves somewhat differently from other <tt>Map</tt>
         * implementations.
         *
        public class WeakHashMap<K,V> extends AbstractMap<K,V> implements Map<K,V> {


    @LinkedHashMap 의 removeEldestEntry.
        :가장 오래된 원소를 삭제한다. 상속하여 사용하라.
    ex)
        Map<Integer, Integer> map = new Cache<>();
        map.put(1, 1);
        map.put(2, 2);
        map.put(3, 1);
        map.put(4, 3);
        System.out.println(map.get(1)); //null

        class Cache<K, V> extends LinkedHashMap<K, V> {
            private static final int MAX_ENTRIES = 3;

            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > MAX_ENTRIES;
            }
        }

        void afterNodeInsertion(boolean evict) { // possibly remove eldest
            LinkedHashMap.Entry<K,V> first;
            if (evict && (first = head) != null && removeEldestEntry(first)) {
                K key = first.key;
                removeNode(hash(key), key, null, false, true);
            }
        }

        /**
         * Returns <tt>true</tt> if this map should remove its eldest entry.
         * This method is invoked by <tt>put</tt> and <tt>putAll</tt> after
         * inserting a new entry into the map.  It provides the implementor
         * with the opportunity to remove the eldest entry each time a new one
         * is added.  This is useful if the map represents a cache: it allows
         * the map to reduce memory consumption by deleting stale entries.
         *
         * @param    eldest The least recently inserted entry in the map, or if
         *           this is an access-ordered map, the least recently accessed
         *           entry.  This is the entry that will be removed it this
         *           method returns <tt>true</tt>.  If the map was empty prior
         *           to the <tt>put</tt> or <tt>putAll</tt> invocation resulting
         *           in this invocation, this will be the entry that was just
         *           inserted; in other words, if the map contains a single
         *           entry, the eldest entry is also the newest.
         * @return   <tt>true</tt> if the eldest entry should be removed
         *           from the map; <tt>false</tt> if it should be retained.
         */
        protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
            return false;
        }

    @WeakReference
        :WeakReference 을 통한 약한 참조 객체는 참조하는 객체가 GC 로부터 회수하는 것을 막지 않는다.


        /**
         * Weak reference objects, which do not prevent their referents from being
         * made finalizable, finalized, and then reclaimed.  Weak references are most
         * often used to implement canonicalizing mappings.
         *
         * <p> Suppose that the garbage collector determines at a certain point in time
         * that an object is <a href="package-summary.html#reachability">weakly
         * reachable</a>.  At that time it will atomically clear all weak references to
         * that object and all weak references to any other weakly-reachable objects
         * from which that object is reachable through a chain of strong and soft
         * references.  At the same time it will declare all of the formerly
         * weakly-reachable objects to be finalizable.  At the same time or at some
         * later time it will enqueue those newly-cleared weak references that are
         * registered with reference queues.
         *
         * @author   Mark Reinhold
         * @since    1.2
         */

        public class WeakReference<T> extends Reference<T> {

        WeakReference<Student> ref = new WeakReference<Student>(new Student("siwoo")); //약한 참조 객체.
        //Student s = ref.get();    //주석을 제거하면 참조를 해제할 수 없으므로 영원히 loop 한다.
        while (ref.get() != null) {
            System.gc();    //하지마라!
        }

        System.out.println(ref.get() == null);

    핵심정리 7. 자기 메모리를 관리하는 클래스에선 null 처리를 확실히 하고,
    WeakHashMap, WeakReference, ScheduledThreadPoolExecutor, LinkedHashMap 등의 메모리 누수 예방법을 익혀두자.

아이템 8. finalizer 와 cleaner 사용을 피하라.
    :자바는 finalizer 와 cleaner 은 객체 소멸자를 제공한다.
    :접근할 수 없게 된 객체를 회수하는 역할은 가비지 컬렉터가 담당한다.
    :이 finalizer 와 cleaner 은 해당 객체의 리소스(파일, 스레드) 등의 시스템이 회수해야할 리소스를 종료하기 위한 목적을 가진다. (하지만 사용하지 마라)

    finalizer 와 cleaner 은 예측 불가하고, 위험하다.
        :finalizer 와 cleaner 는 즉시 수행된다는 보장이 없다.
        :finalizer 스레드는 다른 스레드보다 우선 순위가 낮아 객체 수천 개가 finalizer 대기열에 쌓일 수 있다.

    System.gc 나 System.runFinalization 메서드을 믿지 마라.
        :finalizer 와 cleaner 가 실행될 가능성을 높여줄 수 있으나 보장해주지 않는다.
        :(WeakReference 혹은 WeakHashMap 을 연습할때나 사용하자..)

        /**
         * Runs the garbage collector.
         * <p>
         * Calling the <code>gc</code> method suggests that the Java Virtual
         * Machine expend effort toward recycling unused objects in order to
         * make the memory they currently occupy available for quick reuse.
         * When control returns from the method call, the Java Virtual
         * Machine has made a best effort to reclaim space from all discarded
         * objects.
         * <p>
         * The call <code>System.gc()</code> is effectively equivalent to the
         * call:
         * <blockquote><pre>
         * Runtime.getRuntime().gc()
         * </pre></blockquote>
         *
         * @see     java.lang.Runtime#gc()
         */
        public static void gc() {
            Runtime.getRuntime().gc();
        }

        /**
         * Runs the finalization methods of any objects pending finalization.
         * <p>
         * Calling this method suggests that the Java Virtual Machine expend
         * effort toward running the <code>finalize</code> methods of objects
         * that have been found to be discarded but whose <code>finalize</code>
         * methods have not yet been run. When control returns from the
         * method call, the Java Virtual Machine has made a best effort to
         * complete all outstanding finalizations.
         * <p>
         * The call <code>System.runFinalization()</code> is effectively
         * equivalent to the call:
         * <blockquote><pre>
         * Runtime.getRuntime().runFinalization()
         * </pre></blockquote>
         *
         * @see     java.lang.Runtime#runFinalization()
         */
        public static void runFinalization() {
            Runtime.getRuntime().runFinalization();
        }

     finalizer 와 cleaner 은 심각한 성능 문제도 동반한다.
        :finalizer 와 cleaner 은 가비지 컬렉터의 효율성을 크게 떨어뜨린다.

        @finalizer 공격.
            :생성자나 직렬화 과정(readObject, readResolve) 에서 예외가 발생하면, 이 생성되다 만 객체에서
            악의적인 자식 클래스의 finalizer 가 수행.
            :악의전인 finalizer 메서드는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다.
            :반대로 객체를 직렬화시 클래스를 final 로 선언하거나 finalize 메서드를 final 로 선언하라.

        ex)
            class Name implements Serializable {

                private final String firstName;

                private final String lastName;

                public Name(String firstName, String lastName) {
                    this.firstName = firstName;
                    this.lastName = lastName;
                }
            }

            class Attacker extends Name {
                static final List<Attacker> instances = new ArrayList<>();

                public Attacker(String firstName, String lastName) {
                    super(firstName, lastName);
                }

                private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
                    s.defaultReadObject();
                    throw new IllegalArgumentException();
                }

                @Override
                protected void finalize() throws Throwable {
                    instances.add(this); //to prevent gc to collect this instance.
                }
            }

    finalizer 와 cleaner 의 대안.
        :클래스의 종료해야할 자원(파일, 스레드) 등을 담고 있는 클래스는 AutoCloseable 을 구현하고,
        close 메서드를 호출하라. (try-with-resources) 와 함께.
        :다른 메서드는 이 필드를 검사해 필드의 객체가 닫힌 후 불렸다면 IllegalStateException 을 던져라.


    ex) 회수해야할 자원이 있다면 AutoCloseable 을 구현하라.

        class Http implements AutoCloseable {
            private ObjectInputStream in;
            private HttpContent content;

            public Http(HttpContent content, ObjectInputStream in) {
                this.in = in;
                this.content = content;
            }

            public static Http of(ObjectInputStream in) throws IOException, ClassNotFoundException {
                return new Http((HttpContent) Objects.requireNonNull(in.readObject()), in);
            }

            String content() {
                return content.content;
            }

            String method() {
                return content.method;
            }

            @Override
            public void close() {
                if (Objects.nonNull(in))
                    try {
                        in.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
            }

    그렇다면 finalizer 와 cleaner 은 언제 쓰는가?
        : 자원의 소유자가 close 메서드를 호출하지 않았을 경우의 안정만 역할로 사용.

    ex) FileOutputStream 의 안정망 finalizer

       /**
         * Cleans up the connection to the file, and ensures that the
         * <code>close</code> method of this file output stream is
         * called when there are no more references to this stream.
         *
         * @exception  IOException  if an I/O error occurs.
         * @see        java.io.FileInputStream#close()
         */
        protected void finalize() throws IOException {
            if (fd != null) {
                if (fd == FileDescriptor.out || fd == FileDescriptor.err) {
                    flush();
                } else {
                    /* if fd is shared, the references in FileDescriptor
                     * will ensure that finalizer is only called when
                     * safe to do so. All references using the fd have
                     * become unreachable. We can call close()
                     */
                    close();
                }
            }
        }
    ex)
        public class Room implements AutoCloseable {
            @Override
            public void close() {
                state.run();
            }

            //절대 Room 을 참조하지 말 것! 순환 참조로 가비지 컬렉터 대상에서 제외!
            private static class State implements Runnable {
                int numJunks;

                State(int numJunks) {
                    this.numJunks = numJunks;
                }

                @Override
                public void run() {
                    System.out.println("방 청소");
                    numJunks = 0;
                }
            }

            private final State state;

            public Room(int numJunks) {
                state = new State(numJunks);
            }
        }

        class Adult {
            public static void main(String[] args) {
                try (Room myRoom = new Room(7)) {
                    System.out.println("안녕~");
                }
            }
        }

    cleaner (자바 8 이전은 finalizer) 은 안정망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자.
