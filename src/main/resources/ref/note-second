
아이템 1. "생성자" 대신 "Static Factory Method" 을 고려하라.
    :Static Factory Method 은 생성자와 별도로 그 클래스의 인스턴스를 생성하여 반환하는 메서드다.
    :Static Factory Method 은 생성자보다 더 좋은 장점 5가지를 가진다.

    /**
     * Returns a {@code Boolean} instance representing the specified
     * {@code boolean} value.  If the specified {@code boolean} value
     * is {@code true}, this method returns {@code Boolean.TRUE};
     * if it is {@code false}, this method returns {@code Boolean.FALSE}.
     * If a new {@code Boolean} instance is not required, this method
     * should generally be used in preference to the constructor
     * {@link #Boolean(boolean)}, as this method is likely to yield
     * significantly better space and time performance.
     *
     * @param  b a boolean value.
     * @return a {@code Boolean} instance representing {@code b}.
     * @since  1.4
     */
    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }

    1. Static Factory Method 은 이름을 가질 수 있다.
        :생성자는 반환될 객체의 특성을 제대로 설명하지 못하지만, Static Factory Method 은 이름만 잘 지으면
        반환될 객체의 특성을 쉽게 설명할 수 있다.

        ex)
        public BigInteger(byte[] val)
        public static BigInteger probablePrime(int bitLength, Random seed)
    2. Static Factory Method 은 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
        : 불변 클래스(아이템 17) 을 미리 만들어 놓고 캐싱하여 재사용하는 방법을 채용할 수 있다. (Flyweight Pattern)
        : 해당 클래스를 인스턴스 통제(instance-controlled) 클래스로 만들 수 있다.

        @ToString
        static class Coffee {
            private static final Coffee BLACK = new Coffee("BLACK");
            private final String name;

            private Coffee(String name) {
                this.name = name;
            }

            /**
             * @param name of coffee
             * @throws IllegalArgumentException if name is null
             * @throws IllegalArgumentException if name is empty string
             * @return
             */
            private static Coffee of(String name) {
                checkArgument(Objects.nonNull(name) && !name.isEmpty());
                if ("BLACK".equals(name))
                    return BLACK;
                return new Coffee(name);
            }
        }

        @인스턴스 통제 클래스(instance-controlled) 클래스
            :본인 클래스의 인스턴스를 언제 파괴, 생성할지를 통제하는 클래스.
            :instance-controlled 클래스의 예로는 싱글턴(singleton) 혹은 "불변 값 클래스 (a == b 일때만 a.equal(b) 가 성립)", 열거 타입이 있다.

    3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
        :해당 구현 클래스를 공개하지 않고도 부모 클래스에서 그 객체를 반환하도록 반환할 수 있다.
        :이는 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크에서 자주 사용된다.
        :특정 인터페이스를 구현한 동반 클래스를 private 내부 클래스로 만든 이후 정적 팩토리 메서드로 반환하면
        "개념의 수" 가 줄어들어 클라이언트가 사용하기 편하다.
        :클라이언트는 "인터페이스" 만으로 다루므로 해당 클래스를 다루는 난이도가 낮춰진다.
        :예로는 Collections 의 45 개 유틸리티 구현제가 있다.

        ex)
        static class Collections {

            public static <E> Collection<E> unmodifiableCollection(Collection<? extends E> c) {
                return new UnmodifiableCollection<>(c);
            }

            private static class UnmodifiableCollection<E> implements Collection<E> {
                private final Collection<? extends E> el;

                public UnmodifiableCollection(Collection<? extends E> el) {
                    checkArgument(el != null);
                    this.el = el;
                }

                @Override
                public E get(int index) {
                    return el.get(index);
                }

                @Override
                public void set(int index, E el) {
                    throw new UnsupportedOperationException();
                }
            }
        }

    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
        :3번의 기능을 더 추가한 예로써, 매개변수의 따라 서브 클래스의 "구현체" 를 판단한다.
        :인터페이스를 리턴하므로 클라이언트는 인터페이스에 기반에 따라 프로그래밍한다. 따라서 구현체를 다음 릴리즈에서
        교체하더라도 문제가 없다. (인터페이스 프로그래밍하라)

    ex)
        /**
         * Creates an empty enum set with the specified element type.
         *
         * @param <E> The class of the elements in the set
         * @param elementType the class object of the element type for this enum
         *     set
         * @return An empty enum set of the specified type.
         * @throws NullPointerException if <tt>elementType</tt> is null
         */
        public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
            Enum<?>[] universe = getUniverse(elementType);
            if (universe == null)
                throw new ClassCastException(elementType + " not an enum");
            if (universe.length <= 64)  // Enum 의 갯수에 따라 구현체를 선택한다.
                return new RegularEnumSet<>(elementType, universe);
            else
                return new JumboEnumSet<>(elementType, universe);
        }

    5. 정적 팩터리 메서드를 작정하는 시점에는 반환할 객체의 클래스는 존재하지 않아도 된다.
        :이는 서비스 제공자 프레임워크 (service provider framework) 을 근간이 된다.
        :서비스 제공자 프레임워크는 Service Interface, Provider Registration, Service Access 3가지 핵심 컴포넌트로 이뤄진다.

    ex)
        //Service interface
        static interface Connection {

        }

        //Factory class for Service interface
        static interface Driver {
            Connection getConnection();
        }

        //Class for register and service access.
        static class DriverManager {
            private static final List<Driver> registerDrivers = new CopyOnWriteArrayList<>();

            private DriverManager() { }

            public static synchronized void registerDriver(Driver driver) {
                checkArgument(Objects.nonNull(driver));
                if (!registerDrivers.contains(driver))
                    registerDrivers.add(driver);
            }

            //Static factory method for Service Implementation
            public static Connection getConnection(String url)  {
                for (Driver d: registerDrivers) {
                    Connection con = Objects.requireNonNull(d.getConnection());
                    return con;
                }
                throw new IllegalStateException();
            }
        }

    아이템 1 핵심 정리.
        Static Factory Method 은 대부분 생성자보다 유리한 경우가 더 많으므로 이를 구현함을 항상 고려하자.

아이템 2. 생성자에 선택적 매개변수가 많다면 빌더를 고려하라.
    : 생성자와 Static Factory Method 은 선택적 매개변수가 많을 때 적절히 대응하기 힘들다.

    @점층적 생성자 패턴(telescoping constructor pattern)
        : 생성자의 매개변수를 늘려가는 형태로 하위 생성자는 최상위 생성자를 호출할때까지 위임한다.
        : 점층적이므로 때로는 선택적 매개변수를 필수로 지정할 수 밖에 없는 상황이 있다.
        : 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려우며 버그가 발생한다.

    ex)
    public class NutritionFacts {
        private final int servingSize;       //required
        private final int servings;           //required
        private final OptionalInt calories;
        private final OptionalInt fat;
        private final OptionalInt sodium;
        private final OptionalInt carbohydrate;

        public NutritionFacts(int servingSize, int servings) {
            this(servingSize, servings, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories) {
            this(servingSize, servings, calories, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat) {
            this(servingSize, servings, calories, fat, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
            this(servingSize, servings, calories, fat, sodium, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
            this.servingSize = servingSize;
            this.servings = servings;
            this.calories = calories == 0 ? OptionalInt.empty() : OptionalInt.of(calories);
            this.fat = fat == 0 ? OptionalInt.empty() : OptionalInt.of(fat);
            this.sodium =  sodium == 0 ? OptionalInt.empty() : OptionalInt.of(sodium);
            this.carbohydrate = carbohydrate == 0 ? OptionalInt.empty() : OptionalInt.of(carbohydrate);
        }

        public static void main(String[] args) {
            NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); // 점층적 생성자로는 Optional 값을 대체할 방법이 없다.
        }
    }

    @자바빈즈 패턴.
        :자바빈즈 패턴은 인스턴스를 만들기 쉽고, 더 읽기 쉬운 코드를 만들어준다.
        :자바빈즈는 객체가 만드는 과정(연속적 setter 호출) 동안 일관성(consistency) 가 무너진 상태에 놓인다.
        :"여러 매개변수"에 대한 유효장치를 설정할 수 없다.
        :자바빈즈 패턴은 클래스를 "불변"으로 만들 수 없으며 스레드 안정성을 얻기 어렵다.

    ex)
    public class NutritionFacts {
        private int servingSize = -1;       //required
        private int servings = -1;           //required
        private OptionalInt calories = OptionalInt.empty();
        private OptionalInt fat = OptionalInt.empty();
        private OptionalInt sodium = OptionalInt.empty();
        private OptionalInt carbohydrate = OptionalInt.empty();

        public NutritionFacts() { }

        public void setServingSize(int servingSize) {
            this.servingSize = servingSize;
        }

        public void setServings(int servings) {
            this.servings = servings;
        }

        public void setCalories(int calories) {
            this.calories = OptionalInt.of(calories);
        }

        public void setFat(int fat) {
            this.fat = OptionalInt.of(fat);
        }

        public void setSodium(int sodium) {
            this.sodium = OptionalInt.of(sodium);
        }

        public void setCarbohydrate(int carbohydrate) {
            this.carbohydrate = OptionalInt.of(carbohydrate);
        }

        public static void main(String[] args) {
            //NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);
            NutritionFacts cocaCola = new NutritionFacts();
            cocaCola.setServingSize(240);
            cocaCola.setServingSize(8);
            cocaCola.setCalories(100);
            cocaCola.setSodium(35);
            cocaCola.setCarbohydrate(27);

    빌더 패턴.
        :점층적 생성자 패턴의 안정성과 자바빈즈 패턴의 가독성을 겸비한 패턴.
        :클라이언트는 직접 객체를 생성하는 대신 (생성자를 통해), 세터 메서드들을 제공하는 빌더 객체를 통해 필요한 "불변" 객체를 얻는다.
        :세터 메서드 이후 빌더 자신을 리턴함을 메서드 연쇄(method chaining) 혹은 플루언트 api (fluent api) 라 부른다.
        :build 메서드가 호출하는 생성자에 "불벽식" 을 보장하는 유효 검사를 넣을 수 있다. (아이템 50 - 방어적 복사본을 만든 이후, 이 복사본으로 유효성을 검사하라. - 다른 쓰레드가 복사본을 수성할 시 "불변식"이 다시 깨질 수 있다.)

        @불변식
            : 불변식(invariant) 은 프로그램이 실행되는 동안, 혹은 정해진 기간 동안 반드시 만족해야 하는 조건을 말한다.
            : 예를들어 Period 클래스에서 start 필드의 값은 반드시 end 필드의 값보다 앞서야 하므로, 두 값이 역전되면 "불변식" 이 깨졌다고 한다.
            : 불변을 가장 "엄격한" 불변식의 예라고 볼 수 있다.

    ex)
    public class NutritionFacts {
        private final int servingSize;       //required
        private final int servings;           //required
        private final OptionalInt calories;
        private final OptionalInt fat;
        private final OptionalInt sodium;
        private final OptionalInt carbohydrate;

        private NutritionFacts(Builder b) {
            this.servingSize = b.servingSize;
            this.servings = b.servings;
            this.calories = b.calories;
            this.fat = b.fat;
            this.sodium = b.sodium;
            this.carbohydrate = b.carbohydrate;
        }

        public static class Builder {
            private final int servingSize;
            private final int servings;
            private OptionalInt calories = OptionalInt.empty();
            private OptionalInt fat = OptionalInt.empty();
            private OptionalInt sodium = OptionalInt.empty();
            private OptionalInt carbohydrate = OptionalInt.empty();

            public Builder(int servingSize, int servings) {
                this.servingSize = servingSize;
                this.servings = servings;
            }

            public Builder calories(int val) { calories = OptionalInt.of(val); return this; }
            public Builder fat(int val) { fat = OptionalInt.of(val); return this; }
            public Builder sodium(int val) { sodium = OptionalInt.of(val); return this; }
            public Builder carbohydrate(int val) { carbohydrate = OptionalInt.of(val); return this; }

            public NutritionFacts build() {
                return new NutritionFacts(this);
            }
        }

    빌더 패턴은 계층적 설계된 클래스와 조합이 좋다.
        :추상 클래스는 추상 빌더를, 구체 클래스는 구체 빌더를 따로 구현한다.
        :이때 하위 클래스에서는 형변환 하지 않고 메서드 연쇄를 위해 셀프 타입 관용구(simulated self-type) 를 사용한다.
        :셀프 타입 관용구시 사용되는 제네릭 타입은 "재귀적 타입 한정" 을 사용한다.

        @공변 반환 타이핑(covariant return typing)
            : 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 것을 의미.

    ex)
    public abstract class Pizza {
        public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE }
        final Set<Topping> toppings;

        public Pizza(Builder<?> b) {
            this.toppings = b.toppings.clone(); //raw 타입을 사용하지 마라, 방어적 복사를 하라.
        }

        public abstract static class Builder<T extends Builder<T>> {    //Type Safe 한 Generic Container 매개변수를 사용하라, (T 을 Builder 을 상속한 클래스만 한정하는 재귀적 타입 한정 제네릭 타입)
            private EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

            public T addTopping(Topping topping) {
                toppings.add(Objects.requireNonNull(topping));
                return self();
            }

            abstract Pizza build();

            /**
             * @implSpec
             * 하위 클래스는 이 메서드를 재정의하여 this 을 반환하도록 해야 한다.
             * @return
             */
            abstract T self();
        }
    }

    class NyPizza extends Pizza {
        public enum Size { SMALL, MEDIUM, LARGE }
        private final Size size;

        public static class Builder extends Pizza.Builder<Builder> {
            private final Size size;

            public Builder(Size size) {
                this.size = Objects.requireNonNull(size);
            }

            @Override
            Pizza build() {
                return new NyPizza(this);
            }

            @Override
            Builder self() {
                return this;
            }
        }

        public NyPizza(Builder b) {
            super(b);
            this.size = b.size;
        }
    }

    class Calzone extends Pizza {
        private final boolean sauceInside;

        public static class Builder extends Pizza.Builder<Builder> {
            private boolean sauceInside = false;

            public Builder sauceInside() {
                this.sauceInside = true;
                return this;
            }

            @Override
            Pizza build() {
                return new Calzone(this);
            }

            @Override
            Builder self() {
                return this;
            }
        }

        public Calzone(Builder b) {
            super(b);
            this.sauceInside = b.sauceInside;
        }
    }

    아이템 2 핵심 정리.
        생성자나 정적 팩터리가 처리해야 할 (선택적) 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
        빌더는 점층적 생성자보다 가독성이 좋고, 자바빈즈 보다 훨씬 안전하다.

아이템 3. "private 생성자"나 "열거 타입"으로 싱글턴임을 보증하라.
    @Singleton
        :Singleton 이란 "인스턴스가 하나만 존재"하는 클래스를 뜻한다.
        :Singleton 의 전형적인 예로는 Stateless 객체나 설계상 유일해야 하는 '시스템 컴포넌트'을 들 수 있다.
        :Singleton 은 mock 으로 대체할 수 없어 테스트하기 어렵다.

    Singleton 을 생성하는 두 가지 방법.
        public static 멤버 Singleton.
            : static final 멤버는 초기화할 때 딱 한 번만 호출되므로 인스턴스가 전체 시스템에서 하나뿐임이 보장된다.
            : AccessibleObject.setAccessible 을 이용하여 private 메서드를 호출할 수 있으므로 두 번째 객체가 생성될 때 예외를 던질 수 있다..
        ex)
            public class Elvis {
                public static final Elvis INSTANCE = new Elvis();
                private Elvis() { }

                public void leaveTheBuilding() {
                    ..
                }
            }

        Constructor<?>[] c = Elvis.class.getDeclaredConstructors();
        for (Constructor e: c) {
            e.setAccessible(true);
            Elvis elvis = (Elvis) e.newInstance();
            System.out.println(elvis == Elvis.INSTANCE); //two instance by reflection
        }

        Static factory Method 을 이용한 Singleton
            : 이후에 마음이 바뀌면 싱글턴이 아니게 변경할 수 있으므로 멤버 싱글턴보다 유연하다.
            : 혹은 쓰레드별로 다른 인스턴스를 넘겨줄 수 있다. (인스턴스 통제 클래스: 아이템1)
            : 정적 팩토리를 제네릭 싱글톤 팩토리로 만들 수 있다. (이왕이면 제네릭 메서드로 만들라: 아이템30)
            : Static Factory Method 의 메서드 참조를 이용하여 공급자(Supplier) 로 활용할 수 있다.
            ex)
                Supplier<Elvis> supplier = Elvis::getInstance;
                Elvis elvis = supplier.get();

        ex)
            public class Elvis {
                private static int numOfInstance = 0;       //don't set '0'
                private static final Elvis INSTANCE = new Elvis();

                private Elvis() {
                    numOfInstance++;
                    if (numOfInstance > 1)
                        throw new IllegalStateException();
                }

                public static Elvis getInstance() { return INSTANCE; }

                public void leaveTheBuilding() {
                    ..
                }

    Singleton 클래스 대신 Enum 을 사용하라ㅏ.
        : Enum 은 더 간결하고, 추가 노력 없이 직렬화할 수 있고, 리플렉션 공격에서도 안전하다.
        : 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

   ex)
        enum Singleton {
            INSTANCE;
            Singleton() { }

            public void leaveTheBuilding() {
                System.out.println("Enum over Singleton class");
            }
        }

        Constructor<?>[] c = Singleton.class.getConstructors();
        for (Constructor e: c) { //Constructor[0]
            e.setAccessible(true);
            Singleton singleton = (Singleton) e.newInstance();
            System.out.println(singleton == Singleton.INSTANCE);
        }
